"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ActionSet = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _react = _interopRequireDefault(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _classnames = _interopRequireDefault(require("classnames"));
var _settings = require("../../settings");
var _propsHelper = require("../../global/js/utils/props-helper");
var _react2 = require("@carbon/react");
var _excluded = ["className", "disabled", "kind", "label", "loading", "isExpressive"],
  _excluded2 = ["actions", "buttonSize", "className", "size"];
/**
 * Copyright IBM Corp. 2021, 2021
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
// Import portions of React that are needed.
// Other standard imports.
// Carbon and package components we use.
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var blockClass = "".concat(_settings.pkg.prefix, "--action-set");
var componentName = 'ActionSet';

// NOTE: the component SCSS is not imported here: it is rolled up separately.

var ActionSetButton = /*#__PURE__*/_react.default.forwardRef(function (_ref, ref) {
  var _ref2;
  var className = _ref.className,
    disabled = _ref.disabled,
    kind = _ref.kind,
    label = _ref.label,
    loading = _ref.loading,
    _ref$isExpressive = _ref.isExpressive,
    isExpressive = _ref$isExpressive === void 0 ? true : _ref$isExpressive,
    rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);
  return /*#__PURE__*/_react.default.createElement(_react2.Button, (0, _extends2.default)({}, rest, {
    isExpressive: isExpressive,
    className: (0, _classnames.default)(className, ["".concat(blockClass, "__action-button"), (_ref2 = {}, (0, _defineProperty2.default)(_ref2, "".concat(blockClass, "__action-button--ghost"), kind === 'ghost' || kind === 'danger--ghost'), (0, _defineProperty2.default)(_ref2, "".concat(blockClass, "__action-button--expressive"), isExpressive), _ref2)]),
    disabled: disabled || loading || false,
    kind: kind,
    ref: ref
  }), label, loading && /*#__PURE__*/_react.default.createElement(_react2.InlineLoading, null));
});
ActionSetButton.displayName = 'ActionSetButton';
ActionSetButton.propTypes = _objectSpread(_objectSpread({}, _react2.Button.PropTypes), {}, {
  kind: _propTypes.default.oneOf(['ghost', 'danger--ghost', 'secondary', 'danger', 'primary']),
  label: _propTypes.default.string,
  loading: _propTypes.default.bool
});
var defaultKind = 'primary';
var willStack = function willStack(size, numberOfActions) {
  return size === 'sm' || size === 'md' && numberOfActions > 2;
};

// Default values for props
var defaults = {
  size: 'md'
};

/**
 * An ActionSet presents a set of action buttons, constructed from bundles
 * of prop values and applying some layout rules. When the size is 'sm'
 * the buttons are stacked, and should only include primary and secondary
 * kinds. When the size is 'md' the buttons are stacked if there are three or
 * more. When the size is 'md' or 'lg', two buttons share the horizontal space.
 * When the size is 'lg', three or more buttons use a quarter of the available
 * horizontal space, and if the size is 'xlg' or 'max' the buttons always use
 * a quarter of the available horizontal space. If there is a ghost button,
 * it appears at the left side. If there is a primary button it appears at the
 * right.
 */
var ActionSet = /*#__PURE__*/_react.default.forwardRef(function (_ref3, ref) {
  var _actions$slice, _cx;
  var actions = _ref3.actions,
    buttonSize = _ref3.buttonSize,
    className = _ref3.className,
    _ref3$size = _ref3.size,
    size = _ref3$size === void 0 ? defaults.size : _ref3$size,
    rest = (0, _objectWithoutProperties2.default)(_ref3, _excluded2);
  var buttons = actions && ((_actions$slice = actions.slice) === null || _actions$slice === void 0 ? void 0 : _actions$slice.call(actions, 0)) || [];

  // We stack the buttons in a sm set, or if there are three or more in a md set.
  var stacking = willStack(size, buttons.length);

  // Order of button kinds: ghost first, then danger--ghost, then most other types,
  // then danger, and finally primary
  var buttonOrder = function buttonOrder(kind) {
    var _ghost$dangerGhost$;
    return (_ghost$dangerGhost$ = {
      ghost: 1,
      'danger--ghost': 2,
      danger: 4,
      primary: 5
    }[kind]) !== null && _ghost$dangerGhost$ !== void 0 ? _ghost$dangerGhost$ : 3;
  };

  // order the actions with ghost/ghost-danger buttons first and primary/danger buttons last
  // (or the opposite way if we're stacking)
  buttons.sort(function (action1, action2) {
    return (buttonOrder(action1.kind || defaultKind) - buttonOrder(action2.kind || defaultKind)) * (stacking ? -1 : 1);
  });
  return /*#__PURE__*/_react.default.createElement(_react2.ButtonSet, (0, _extends2.default)({}, rest, {
    className: (0, _classnames.default)(blockClass, className, (_cx = {}, (0, _defineProperty2.default)(_cx, "".concat(blockClass, "--row-single"), !stacking && buttons.length === 1), (0, _defineProperty2.default)(_cx, "".concat(blockClass, "--row-double"), !stacking && buttons.length === 2), (0, _defineProperty2.default)(_cx, "".concat(blockClass, "--row-triple"), !stacking && buttons.length === 3), (0, _defineProperty2.default)(_cx, "".concat(blockClass, "--row-quadruple"), !stacking && buttons.length >= 4), (0, _defineProperty2.default)(_cx, "".concat(blockClass, "--stacking"), stacking), _cx), "".concat(blockClass, "--").concat(size)),
    ref: ref,
    role: "presentation",
    stacked: stacking
  }), buttons.map(function (action, index) {
    return /*#__PURE__*/_react.default.createElement(ActionSetButton, (0, _extends2.default)({
      key: action.key || index
    }, action, {
      size: buttonSize
    }));
  }));
});
exports.ActionSet = ActionSet;
ActionSet.displayName = componentName;

/**
 * A validator function to help validate the actions supplied for a particular
 * size of component. When the size is sm, or md with three actions, the
 * buttons will be stacked and a maximum of three buttons is applied with no
 * ghosts unless the ghost is the only button. Otherwise a maximum of four
 * buttons with a maximum of one ghost is applied. In either case, a maximum
 * of one primary button is allowed.
 * @param sizeFn An optional function which will be passed all the props and
 * returns the size that the component should be treated as being: if not
 * provided, a 'size' prop is used to determine the size of the component.
 * @returns null if the actions meet the requirements, or an Error object with
 * an explanatory message.
 */
ActionSet.validateActions = function (sizeFn) {
  return function (props, propName, componentName, location, propFullName) {
    var name = propFullName || propName;
    var prop = props[name];
    var actions = prop && (prop === null || prop === void 0 ? void 0 : prop.length);
    var problems = [];
    if (actions > 0) {
      // eslint-disable-next-line react/prop-types
      var size = sizeFn ? sizeFn(props) : props.size || defaults.size;
      var stacking = willStack(size, actions);
      var countActions = function countActions(kind) {
        return prop.filter(function (action) {
          return (action.kind || defaultKind) === kind;
        }).length;
      };
      var primaryActions = countActions('primary');
      var secondaryActions = countActions('secondary');
      var dangerActions = countActions('danger');
      var ghostActions = countActions('ghost') + countActions('danger--ghost');
      stacking && actions > 3 && problems.push("you cannot have more than three actions in this size of ".concat(componentName));
      actions > 4 && problems.push("you cannot have more than four actions in a ".concat(componentName));
      primaryActions > 1 && problems.push("you cannot have more than one 'primary' action in a ".concat(componentName));
      ghostActions > 1 && problems.push("you cannot have more than one 'ghost' action in a ".concat(componentName));
      stacking && actions > 1 && ghostActions > 0 && problems.push("you cannot have a 'ghost' button in conjunction with other action types in this size of ".concat(componentName));
      actions > primaryActions + secondaryActions + dangerActions + ghostActions && problems.push("you can only have 'primary', 'danger', 'secondary', 'ghost' and 'danger--ghost' buttons in a ".concat(componentName));
    }
    return problems.length > 0 ? new Error("Invalid ".concat(location, " `").concat(name, "` supplied to `").concat(componentName, "`: ").concat(problems.join(', and '), ".")) : null;
  };
};
ActionSet.propTypes = {
  /**
   * The action buttons to show. Each action is specified as an
   * object with optional fields 'label' to supply the button label, 'kind'
   * to select the button kind (must be 'primary', 'secondary' or 'ghost'),
   * 'loading' to display a loading indicator, and 'onClick' to receive
   * notifications when the button is clicked. Additional fields in the object
   * will be passed to the Button component, and these can include 'disabled',
   * 'ref', 'className', and any other Button props. Any other fields in the
   * object will be passed through to the button element as HTML attributes.
   *
   * See https://react.carbondesignsystem.com/?path=/docs/components-button--default#component-api
   */
  actions: (0, _propsHelper.allPropTypes)([ActionSet.validateActions(), _propTypes.default.arrayOf(_propTypes.default.shape(_objectSpread(_objectSpread({}, _react2.Button.propTypes), {}, {
    kind: _propTypes.default.oneOf(['ghost', 'danger--ghost', 'secondary', 'danger', 'primary']),
    label: _propTypes.default.string,
    loading: _propTypes.default.bool,
    // we duplicate this Button prop to improve the DocGen here
    onClick: _react2.Button.propTypes.onClick
  })))]),
  /**
   * The size of buttons to use for the actions. The allowed values are
   * those for the size prop of carbon Button. If this prop is specified, all
   * the buttons will be set to this size, overriding any 'size' values (if any)
   * supplied in the actions array (if any).
   */
  buttonSize: _react2.Button.propTypes.size,
  /**
   * An optional class or classes to be added to the outermost element.
   */
  className: _propTypes.default.string,
  /**
   * The size of the action set. Different button arrangements are used at
   * different sizes, to make best use of the available space.
   */
  size: _propTypes.default.oneOf(['sm', 'md', 'lg', 'xl', '2xl'])
};