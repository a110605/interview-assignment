"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof3 = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deprecatedProps = exports.EditInPlace = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _react = _interopRequireWildcard(require("react"));
var _react2 = require("@carbon/react");
var _classnames = _interopRequireDefault(require("classnames"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _icons = require("@carbon/react/icons");
var _settings = require("../../settings");
var _devtools = require("../../global/js/utils/devtools");
var _excluded = ["cancelLabel", "editAlwaysVisible", "editLabel", "id", "inheritTypography", "invalid", "invalidLabel", "invalidText", "labelText", "onCancel", "onChange", "onSave", "saveLabel", "size", "tooltipAlignment", "value"];
/**
 * Copyright IBM Corp. 2022, 2022
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var componentName = 'EditInPlace';
var blockClass = "".concat(_settings.pkg.prefix, "--edit-in-place");
var defaults = {
  tooltipAlignment: 'top',
  size: 'sm'
};
var EditInPlace = /*#__PURE__*/(0, _react.forwardRef)(function (_ref, ref) {
  var _cx;
  var cancelLabel = _ref.cancelLabel,
    editAlwaysVisible = _ref.editAlwaysVisible,
    editLabel = _ref.editLabel,
    id = _ref.id,
    inheritTypography = _ref.inheritTypography,
    invalid = _ref.invalid,
    deprecated_invalidLabel = _ref.invalidLabel,
    invalidText = _ref.invalidText,
    labelText = _ref.labelText,
    onCancel = _ref.onCancel,
    onChange = _ref.onChange,
    onSave = _ref.onSave,
    saveLabel = _ref.saveLabel,
    _ref$size = _ref.size,
    size = _ref$size === void 0 ? defaults.size : _ref$size,
    tooltipAlignment = _ref.tooltipAlignment,
    value = _ref.value,
    rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);
  var _useState = (0, _react.useState)(false),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    focused = _useState2[0],
    setFocused = _useState2[1];
  var _useState3 = (0, _react.useState)(''),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    initialValue = _useState4[0],
    setInitialValue = _useState4[1];
  var _useState5 = (0, _react.useState)(false),
    _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
    dirtyInput = _useState6[0],
    setDirtyInput = _useState6[1];
  var inputRef = (0, _react.useRef)(null);
  var canSave = value !== initialValue && !invalid;
  var escaping = (0, _react.useRef)(false);
  var tipAlignIsObject = (0, _typeof2.default)(tooltipAlignment) === 'object';
  var tipAlignments = ['edit', 'save', 'cancel'].reduce(function (acc, tips) {
    var _ref2;
    acc[tips] = (_ref2 = tipAlignIsObject ? tooltipAlignment[tips] : tooltipAlignment) !== null && _ref2 !== void 0 ? _ref2 : defaults.tooltipAlignment;
    return acc;
  }, {});
  (0, _react.useEffect)(function () {
    if (!initialValue && !dirtyInput) {
      setInitialValue(value);
    }
  }, [initialValue, dirtyInput, value]);
  var isTargetingChild = function isTargetingChild(_ref3) {
    var currentTarget = _ref3.currentTarget,
      relatedTarget = _ref3.relatedTarget;
    return currentTarget.contains(relatedTarget);
  };
  var onChangeHandler = function onChangeHandler(_ref4) {
    var target = _ref4.target;
    if (!dirtyInput) {
      setDirtyInput(true);
    }
    onChange(target.value);
  };
  var onFocusHandler = function onFocusHandler(e) {
    // if (readOnly) {
    //   return;
    // }

    if (!isTargetingChild(e)) {
      inputRef.current.focus();
      setFocused(true);
    }
  };
  var onSaveHandler = function onSaveHandler() {
    setInitialValue(value);
    setFocused(false);
    setDirtyInput(false);
    onSave();
  };
  var onCancelHandler = function onCancelHandler() {
    setFocused(false);
    setDirtyInput(false);
    onCancel(initialValue);
  };
  var onBlurHandler = function onBlurHandler(e) {
    // if (readOnly || escaping.current) {
    if (escaping.current) {
      return;
    }
    if (!isTargetingChild(e)) {
      if (canSave) {
        onSaveHandler();
      } else {
        onCancelHandler();
      }
    }
  };
  var returnHandler = function returnHandler() {
    if (canSave) {
      onSaveHandler();
    }
  };
  var escapeHandler = function escapeHandler() {
    onCancelHandler();
  };
  var onKeyHandler = function onKeyHandler(e) {
    // to prevent blur handler from being called twice add additional state to check if escape is being used
    escaping.current = true;
    switch (e.key) {
      case 'Escape':
        inputRef.current.blur();
        escapeHandler();
        break;
      case 'Enter':
        inputRef.current.blur();
        returnHandler();
        break;
      default:
        break;
    }
    escaping.current = false;
  };
  return /*#__PURE__*/_react.default.createElement("div", (0, _extends2.default)({}, rest, {
    ref: ref
  }, (0, _devtools.getDevtoolsProps)(componentName)), /*#__PURE__*/_react.default.createElement("div", {
    className: (0, _classnames.default)(blockClass, "".concat(blockClass, "--").concat(size), (_cx = {}, (0, _defineProperty2.default)(_cx, "".concat(blockClass, "--focused"), focused), (0, _defineProperty2.default)(_cx, "".concat(blockClass, "--invalid"), invalid), (0, _defineProperty2.default)(_cx, "".concat(blockClass, "--inherit-type"), inheritTypography), (0, _defineProperty2.default)(_cx, "".concat(blockClass, "--overflows"), inputRef.current && inputRef.current.scrollWidth > inputRef.current.offsetWidth), _cx)),
    onFocus: onFocusHandler,
    onBlur: onBlurHandler
  }, /*#__PURE__*/_react.default.createElement("label", {
    className: "".concat(blockClass, "__text-input-label"),
    htmlFor: id
  }, labelText), /*#__PURE__*/_react.default.createElement("input", {
    id: id,
    className: (0, _classnames.default)("".concat(blockClass, "__text-input"), "".concat(_settings.carbon.prefix, "--text-input"), "".concat(_settings.carbon.prefix, "--text-input--").concat(size)),
    type: "text",
    value: value,
    onChange: onChangeHandler,
    ref: inputRef
    // readOnly={readOnly}
    ,
    onKeyDown: onKeyHandler
  }), /*#__PURE__*/_react.default.createElement("div", {
    className: "".concat(blockClass, "__ellipsis"),
    "aria-hidden": !focused
  }, "\u2026"), /*#__PURE__*/_react.default.createElement("div", {
    className: "".concat(blockClass, "__toolbar")
  }, invalid && /*#__PURE__*/_react.default.createElement(_icons.WarningFilled, {
    size: 16,
    className: "".concat(blockClass, "__warning-icon")
  }), focused ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_react2.IconButton, {
    align: tipAlignments.cancel,
    size: size,
    label: cancelLabel,
    onClick: onCancelHandler,
    kind: "ghost",
    tabIndex: 0,
    key: "cancel",
    className: "".concat(blockClass, "__btn ").concat(blockClass, "__btn-cancel")
  }, /*#__PURE__*/_react.default.createElement(_icons.Close, {
    size: 16
  })), /*#__PURE__*/_react.default.createElement(_react2.IconButton, {
    align: tipAlignments.save,
    size: size,
    label: saveLabel,
    onClick: onSaveHandler,
    kind: "ghost",
    tabIndex: 0,
    key: "save",
    className: "".concat(blockClass, "__btn ").concat(blockClass, "__btn-save"),
    disabled: !canSave
  }, /*#__PURE__*/_react.default.createElement(_icons.Checkmark, {
    size: 16
  }))) : /*#__PURE__*/_react.default.createElement(_react2.IconButton, {
    align: tipAlignments.edit,
    className: (0, _classnames.default)("".concat(blockClass, "__btn"), "".concat(blockClass, "__btn-edit"), (0, _defineProperty2.default)({}, "".concat(blockClass, "__btn-edit--always-visible"), editAlwaysVisible)),
    size: size,
    label: editLabel,
    onClick: onFocusHandler,
    kind: "ghost",
    tabIndex: 0,
    key: "edit"
  }, /*#__PURE__*/_react.default.createElement(_icons.Edit, {
    size: 16
  })))), invalid && /*#__PURE__*/_react.default.createElement("p", {
    className: "".concat(blockClass, "__warning-text")
  }, invalidText !== null && invalidText !== void 0 ? invalidText : deprecated_invalidLabel));
});
exports.EditInPlace = EditInPlace;
exports.EditInPlace = EditInPlace = _settings.pkg.checkComponentEnabled(EditInPlace, componentName);
EditInPlace.displayName = componentName;
var deprecatedProps = {
  /**
   * **Deprecated**
   * invalidLabel was misnamed, using invalidText to match Carbon
   */
  invalidText: _propTypes.default.string
};
exports.deprecatedProps = deprecatedProps;
var alignPropType = _propTypes.default.oneOf(['top', 'top-left', 'top-right', 'bottom', 'bottom-left', 'bottom-right', 'left', 'right']);
EditInPlace.propTypes = _objectSpread({
  /**
   * label for cancel button
   */
  cancelLabel: _propTypes.default.string.isRequired,
  /**
   * By default the edit icon is shown on hover only.
   */
  editAlwaysVisible: _propTypes.default.bool,
  /**
  /**
   * label for edit button
   */
  editLabel: _propTypes.default.string.isRequired,
  /**
   * Specify a custom id for the input
   */
  id: _propTypes.default.string.isRequired,
  /**
   * inheritTypography - causes the text entry field to inherit typography settings
   * assigned to the container. This is useful when editing titles for instance.
   *
   * NOTE: The size property limits the vertical size of the input element.
   * Inherited font's should be selected to fit within the size selected.
   */
  inheritTypography: _propTypes.default.bool,
  /**
   * determines if the input is invalid
   */
  invalid: _propTypes.default.bool,
  /**
   * text that is displayed if the input is invalid
   */
  invalidText: _propTypes.default.string,
  /**
   * Provide the text that will be read by a screen reader when visiting this control
   */
  labelText: _propTypes.default.string.isRequired,
  /**
   * handler that is called when the cancel button is pressed or when the user removes focus from the input and there is no new value
   */
  onCancel: _propTypes.default.func.isRequired,
  /**
   * handler that is called when the input is updated
   */
  onChange: _propTypes.default.func.isRequired,
  /**
   * handler that is called when the save button is pressed or when the user removes focus from the input if it has a new value
   */
  onSave: _propTypes.default.func.isRequired,
  /**
   * determines if the input is in readOnly mode
   */
  // readOnly: PropTypes.bool,
  /**
   * label for the edit button that displays when in read only mode
   */
  // readOnlyLabel: PropTypes.string,
  /**
   * label for save button
   */
  saveLabel: _propTypes.default.string.isRequired,
  /**
   * vertical size of control
   */
  size: _propTypes.default.oneOf(['sm', 'md', 'lg']),
  /**
   * tooltipAlignment from the standard tooltip. Default center.
   *
   * Can be passed either as one of tooltip options or as an object specifying cancel, edit and save separately
   */
  tooltipAlignment: _propTypes.default.oneOfType([alignPropType, _propTypes.default.shape({
    cancel: alignPropType,
    edit: alignPropType,
    save: alignPropType
  })]),
  /**
   * current value of the input
   */
  value: _propTypes.default.string.isRequired
}, deprecatedProps);