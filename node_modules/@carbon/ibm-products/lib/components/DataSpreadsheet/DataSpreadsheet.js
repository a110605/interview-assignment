"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof3 = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataSpreadsheet = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _react = _interopRequireWildcard(require("react"));
var _reactTable = require("react-table");
var _propTypes = _interopRequireDefault(require("prop-types"));
var _classnames = _interopRequireDefault(require("classnames"));
var _settings = require("../../settings");
var _DataSpreadsheetBody = require("./DataSpreadsheetBody");
var _DataSpreadsheetHeader = require("./DataSpreadsheetHeader");
var _devtools = require("../../global/js/utils/devtools");
var _getScrollbarWidth = require("../../global/js/utils/getScrollbarWidth");
var _hooks = require("../../global/js/hooks");
var _uuidv = _interopRequireDefault(require("../../global/js/utils/uuidv4"));
var _deepCloneObject = require("../../global/js/utils/deepCloneObject");
var _hooks2 = require("./hooks");
var _createActiveCellFn = require("./utils/createActiveCellFn");
var _getCellSize = require("./utils/getCellSize");
var _handleMultipleKeys = require("./utils/handleMultipleKeys");
var _handleHeaderCellSelection = require("./utils/handleHeaderCellSelection");
var _removeCellSelections = require("./utils/removeCellSelections");
var _selectAllCells = require("./utils/selectAllCells");
var _handleEditSubmit = require("./utils/handleEditSubmit");
var _handleActiveCellInSelectionEnter = require("./utils/handleActiveCellInSelectionEnter");
var _handleActiveCellInSelectionTab = require("./utils/handleActiveCellInSelectionTab");
var _handleCellDeletion = require("./utils/handleCellDeletion");
var _excluded = ["cellSize", "className", "columns", "data", "defaultEmptyRowCount", "onDataUpdate", "id", "onActiveCellChange", "onSelectionAreaChange", "selectAllAriaLabel", "spreadsheetAriaLabel", "theme", "totalVisibleColumns"];
/**
 * Copyright IBM Corp. 2022, 2022
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
// Import portions of React that are needed.
// Other standard imports.
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
// cspell:words rowcount colcount
// The block part of our conventional BEM class names (blockClass__E--M).
var blockClass = "".concat(_settings.pkg.prefix, "--data-spreadsheet");
var componentName = 'DataSpreadsheet';

// Default values for props
var defaults = {
  cellSize: 'sm',
  columns: Object.freeze([]),
  data: Object.freeze([]),
  defaultEmptyRowCount: 16,
  onDataUpdate: Object.freeze(function () {}),
  onActiveCellChange: Object.freeze(function () {}),
  onSelectionAreaChange: Object.freeze(function () {}),
  theme: 'light'
};

/**
 * DataSpreadsheet: used to organize and display large amounts of structured data, separated by columns and rows in a grid-like format.
 */
var DataSpreadsheet = /*#__PURE__*/_react.default.forwardRef(function (_ref, ref) {
  var _cx;
  var _ref$cellSize = _ref.cellSize,
    cellSize = _ref$cellSize === void 0 ? defaults.cellSize : _ref$cellSize,
    className = _ref.className,
    _ref$columns = _ref.columns,
    columns = _ref$columns === void 0 ? defaults.columns : _ref$columns,
    _ref$data = _ref.data,
    data = _ref$data === void 0 ? defaults.data : _ref$data,
    _ref$defaultEmptyRowC = _ref.defaultEmptyRowCount,
    defaultEmptyRowCount = _ref$defaultEmptyRowC === void 0 ? defaults.defaultEmptyRowCount : _ref$defaultEmptyRowC,
    _ref$onDataUpdate = _ref.onDataUpdate,
    onDataUpdate = _ref$onDataUpdate === void 0 ? defaults.onDataUpdate : _ref$onDataUpdate,
    id = _ref.id,
    _ref$onActiveCellChan = _ref.onActiveCellChange,
    onActiveCellChange = _ref$onActiveCellChan === void 0 ? defaults.onActiveCellChange : _ref$onActiveCellChan,
    _ref$onSelectionAreaC = _ref.onSelectionAreaChange,
    onSelectionAreaChange = _ref$onSelectionAreaC === void 0 ? defaults.onSelectionAreaChange : _ref$onSelectionAreaC,
    selectAllAriaLabel = _ref.selectAllAriaLabel,
    spreadsheetAriaLabel = _ref.spreadsheetAriaLabel,
    theme = _ref.theme,
    totalVisibleColumns = _ref.totalVisibleColumns,
    rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);
  var multiKeyTrackingRef = (0, _react.useRef)();
  var localRef = (0, _react.useRef)();
  var spreadsheetRef = ref || localRef;
  var focusedElement = (0, _hooks.useActiveElement)();
  var _useState = (0, _react.useState)(false),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    containerHasFocus = _useState2[0],
    setContainerHasFocus = _useState2[1];
  var _useState3 = (0, _react.useState)(null),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    activeCellCoordinates = _useState4[0],
    setActiveCellCoordinates = _useState4[1];
  var _useState5 = (0, _react.useState)([]),
    _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
    selectionAreas = _useState6[0],
    setSelectionAreas = _useState6[1];
  var _useState7 = (0, _react.useState)([]),
    _useState8 = (0, _slicedToArray2.default)(_useState7, 2),
    selectionAreaData = _useState8[0],
    setSelectionAreaData = _useState8[1];
  var _useState9 = (0, _react.useState)(false),
    _useState10 = (0, _slicedToArray2.default)(_useState9, 2),
    clickAndHoldActive = _useState10[0],
    setClickAndHoldActive = _useState10[1];
  var _useState11 = (0, _react.useState)(''),
    _useState12 = (0, _slicedToArray2.default)(_useState11, 2),
    currentMatcher = _useState12[0],
    setCurrentMatcher = _useState12[1];
  var _useState13 = (0, _react.useState)(false),
    _useState14 = (0, _slicedToArray2.default)(_useState13, 2),
    isEditing = _useState14[0],
    setIsEditing = _useState14[1];
  var _useState15 = (0, _react.useState)(''),
    _useState16 = (0, _slicedToArray2.default)(_useState15, 2),
    cellEditorValue = _useState16[0],
    setCellEditorValue = _useState16[1];
  var _useState17 = (0, _react.useState)(false),
    _useState18 = (0, _slicedToArray2.default)(_useState17, 2),
    headerCellHoldActive = _useState18[0],
    setHeaderCellHoldActive = _useState18[1];
  var _useState19 = (0, _react.useState)(false),
    _useState20 = (0, _slicedToArray2.default)(_useState19, 2),
    activeCellInsideSelectionArea = _useState20[0],
    setActiveCellInsideSelectionArea = _useState20[1];
  var previousState = (0, _hooks.usePreviousValue)({
    activeCellCoordinates: activeCellCoordinates,
    isEditing: isEditing
  });
  var cellSizeValue = (0, _getCellSize.getCellSize)(cellSize);
  var cellEditorRef = (0, _react.useRef)();
  var _useState21 = (0, _react.useState)(),
    _useState22 = (0, _slicedToArray2.default)(_useState21, 2),
    activeCellContent = _useState22[0],
    setActiveCellContent = _useState22[1];
  var activeCellRef = (0, _react.useRef)();
  var cellEditorRulerRef = (0, _react.useRef)();
  var defaultColumn = (0, _react.useMemo)(function () {
    return {
      width: 150,
      rowHeaderWidth: 64,
      rowHeight: cellSizeValue
    };
  }, [cellSizeValue]);
  var _useMultipleKeyTracki = (0, _hooks2.useMultipleKeyTracking)({
      ref: multiKeyTrackingRef,
      containerHasFocus: containerHasFocus,
      isEditing: isEditing
    }),
    keysPressedList = _useMultipleKeyTracki.keysPressedList,
    usingMac = _useMultipleKeyTracki.usingMac;
  var scrollBarSize = (0, _react.useMemo)(function () {
    return (0, _getScrollbarWidth.getScrollbarWidth)();
  }, []);
  var _useTable = (0, _reactTable.useTable)({
      columns: columns,
      data: data,
      defaultColumn: defaultColumn
    }, _reactTable.useBlockLayout, _reactTable.useColumnOrder),
    getTableProps = _useTable.getTableProps,
    getTableBodyProps = _useTable.getTableBodyProps,
    headerGroups = _useTable.headerGroups,
    rows = _useTable.rows,
    totalColumnsWidth = _useTable.totalColumnsWidth,
    prepareRow = _useTable.prepareRow,
    setColumnOrder = _useTable.setColumnOrder,
    visibleColumns = _useTable.visibleColumns;

  // Update the spreadsheet data after editing a cell
  var updateData = (0, _react.useCallback)(function (rowIndex, columnId, newValue) {
    onDataUpdate(function (prev) {
      return prev.map(function (row, index) {
        if (index === rowIndex) {
          return _objectSpread(_objectSpread({}, prev[rowIndex]), {}, (0, _defineProperty2.default)({}, columnId, cellEditorValue || newValue));
        }
        return row;
      });
    });
  }, [cellEditorValue, onDataUpdate]);

  // Removes the active cell element
  var removeActiveCell = (0, _react.useCallback)(function () {
    var activeCellHighlight = spreadsheetRef.current.querySelector(".".concat(blockClass, "__active-cell--highlight"));
    activeCellHighlight.style.display = 'none';
  }, [spreadsheetRef]);
  var removeCellEditor = (0, _react.useCallback)(function () {
    setCellEditorValue('');
    setIsEditing(false);
    cellEditorRef.current.style.display = 'none';
  }, []);

  // Remove cell editor if the active cell coordinates change and save with new cell data, this will
  // happen if you click on another cell while isEditing is true
  (0, _react.useEffect)(function () {
    var prevCoords = previousState === null || previousState === void 0 ? void 0 : previousState.activeCellCoordinates;
    if (((prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.row) !== (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) || (prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.column) !== (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column)) && isEditing) {
      var cellProps = rows[prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.row].cells[prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.column];
      removeCellEditor();
      updateData(prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.row, cellProps.column.id);
      cellEditorRulerRef.current.textContent = '';
    }
    if ((prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.row) !== (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) || (prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.column) !== (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column)) {
      if (activeCellCoordinates && (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) !== 'header' && (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) !== 'header') {
        var activeCellFullData = typeof (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) === 'number' && typeof (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'number' ? rows[activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row].cells[activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column] : null;
        setActiveCellContent(activeCellFullData.render('Cell'));
      }
      if (activeCellCoordinates && (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'header' || (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) === 'header') {
        setActiveCellContent(null);
      }
    }
  }, [activeCellCoordinates, previousState === null || previousState === void 0 ? void 0 : previousState.activeCellCoordinates, updateData, rows, isEditing, removeCellEditor, activeCellContent]);
  var createActiveCell = (0, _react.useCallback)(function (_ref2) {
    var placementElement = _ref2.placementElement,
      coords = _ref2.coords,
      _ref2$addToHeader = _ref2.addToHeader,
      addToHeader = _ref2$addToHeader === void 0 ? false : _ref2$addToHeader;
    var activeCellFullData = typeof (coords === null || coords === void 0 ? void 0 : coords.column) === 'number' && typeof (coords === null || coords === void 0 ? void 0 : coords.row) === 'number' ? rows[coords === null || coords === void 0 ? void 0 : coords.row].cells[coords === null || coords === void 0 ? void 0 : coords.column] : null;
    var activeCellValue = activeCellFullData ? Object.values(activeCellFullData.row.values)[coords === null || coords === void 0 ? void 0 : coords.column] : null;
    var prevCoords = previousState === null || previousState === void 0 ? void 0 : previousState.activeCellCoordinates;
    // Only create an active cell if the activeCellCoordinates have changed
    if ((prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.row) !== (coords === null || coords === void 0 ? void 0 : coords.row) || (prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.column) !== (coords === null || coords === void 0 ? void 0 : coords.column)) {
      (0, _createActiveCellFn.createActiveCellFn)({
        placementElement: placementElement,
        coords: coords,
        addToHeader: addToHeader,
        contextRef: spreadsheetRef,
        blockClass: blockClass,
        onActiveCellChange: onActiveCellChange,
        activeCellValue: activeCellValue,
        activeCellRef: activeCellRef,
        cellEditorRef: cellEditorRef,
        defaultColumn: defaultColumn
      });
    }
  }, [spreadsheetRef, rows, onActiveCellChange, previousState === null || previousState === void 0 ? void 0 : previousState.activeCellCoordinates, defaultColumn]);
  (0, _hooks2.useResetSpreadsheetFocus)({
    focusedElement: focusedElement,
    removeActiveCell: removeActiveCell,
    setContainerHasFocus: setContainerHasFocus
  });
  (0, _hooks2.useSpreadsheetOutsideClick)({
    spreadsheetRef: spreadsheetRef,
    setActiveCellCoordinates: setActiveCellCoordinates,
    setSelectionAreas: setSelectionAreas,
    removeActiveCell: removeActiveCell,
    removeCellSelections: _removeCellSelections.removeCellSelections,
    setContainerHasFocus: setContainerHasFocus,
    removeCellEditor: removeCellEditor
  });
  (0, _hooks2.useMoveActiveCell)({
    spreadsheetRef: spreadsheetRef,
    activeCellCoordinates: activeCellCoordinates,
    containerHasFocus: containerHasFocus,
    createActiveCell: createActiveCell
  });
  var handleInitialArrowPress = (0, _react.useCallback)(function () {
    // If activeCellCoordinates is null then we need to set an initial value
    // which will place the activeCell on the select all cell/button
    setActiveCellInsideSelectionArea(false);
    if (!activeCellCoordinates) {
      setActiveCellCoordinates({
        column: 'header',
        row: 'header'
      });
    }
    return;
  }, [activeCellCoordinates]);
  var updateActiveCellCoordinates = (0, _react.useCallback)(function (_ref3) {
    var _ref3$coords = _ref3.coords,
      coords = _ref3$coords === void 0 ? _objectSpread({}, activeCellCoordinates) : _ref3$coords,
      updatedValue = _ref3.updatedValue,
      _ref3$optOutOfSelecti = _ref3.optOutOfSelectionAreaUpdate,
      optOutOfSelectionAreaUpdate = _ref3$optOutOfSelecti === void 0 ? false : _ref3$optOutOfSelecti;
    var newActiveCell = _objectSpread(_objectSpread({}, coords), updatedValue);
    setActiveCellCoordinates(newActiveCell);
    // Only run if the active cell is _not_ a header cell. This will add a point1 object
    // to selectionAreas every time the active cell changes, allowing us to create cell
    // selections using keyboard. Opting out of the selection area updates here means
    // that the active cell is being moved within a selection area
    if (newActiveCell.row !== 'header' && newActiveCell.column !== 'header' && !optOutOfSelectionAreaUpdate) {
      var tempMatcher = (0, _uuidv.default)();
      setSelectionAreas([{
        point1: newActiveCell,
        matcher: tempMatcher
      }]);
      setCurrentMatcher(tempMatcher);
    }
  }, [activeCellCoordinates]);
  var handleHomeEndKey = (0, _react.useCallback)(function (_ref4) {
    var type = _ref4.type;
    var coordinatesClone = _objectSpread({}, activeCellCoordinates);
    updateActiveCellCoordinates({
      coords: coordinatesClone,
      updatedValue: {
        column: type === 'home' ? 0 : columns.length - 1
      }
    });
    (0, _removeCellSelections.removeCellSelections)({
      spreadsheetRef: spreadsheetRef
    });
  }, [activeCellCoordinates, updateActiveCellCoordinates, spreadsheetRef, columns.length]);
  var handleKeyPress = (0, _react.useCallback)(function (event) {
    var key = event.key;
    if (isEditing) {
      return;
    }
    // Command keys need to be returned as there is default browser behavior with these keys
    if (key === 'Meta' || key === 'Control') {
      return;
    }
    // Prevent arrow keys, home key, and end key from scrolling the page when the data spreadsheet container has focus
    if (['End', 'Home', 'ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown'].indexOf(key) > -1 && !isEditing) {
      event.preventDefault();
    }
    if (['Tab'].indexOf(key) > -1 && isEditing) {
      return;
    }
    // Clear out all cell selection areas if user uses any arrow key, except if the shift key is being held
    if (['ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown'].indexOf(key) > -1) {
      if (selectionAreas !== null && selectionAreas !== void 0 && selectionAreas.length && keysPressedList.length < 2 && !(0, _handleMultipleKeys.includesShift)(keysPressedList)) {
        setSelectionAreas([]);
        setSelectionAreaData([]);
        (0, _removeCellSelections.removeCellSelections)({
          spreadsheetRef: spreadsheetRef
        });
      }
    }
    if (!isEditing && (keysPressedList === null || keysPressedList === void 0 ? void 0 : keysPressedList.length) > 1) {
      (0, _handleMultipleKeys.handleMultipleKeys)({
        activeCellCoordinates: activeCellCoordinates,
        event: event,
        keysPressedList: keysPressedList,
        selectionAreas: selectionAreas,
        currentMatcher: currentMatcher,
        rows: rows,
        setSelectionAreas: setSelectionAreas,
        columns: columns,
        updateActiveCellCoordinates: updateActiveCellCoordinates,
        spreadsheetRef: spreadsheetRef,
        removeCellSelections: _removeCellSelections.removeCellSelections,
        blockClass: blockClass,
        setCurrentMatcher: setCurrentMatcher,
        usingMac: usingMac
      });
    }
    var deleteParams = {
      selectionAreas: selectionAreas,
      currentMatcher: currentMatcher,
      rows: rows,
      setActiveCellContent: setActiveCellContent,
      updateData: updateData,
      activeCellCoordinates: activeCellCoordinates
    };
    // Allow arrow key navigation if there are less than two activeKeys OR
    // if one of the activeCellCoordinates is in a header position
    if (keysPressedList.length < 2 && !(0, _handleMultipleKeys.includesShift)(keysPressedList) || activeCellCoordinates.row === 'header' || activeCellCoordinates.column === 'header') {
      switch (key) {
        // Backspace
        case 'Backspace':
          {
            (0, _handleCellDeletion.handleCellDeletion)(deleteParams);
            break;
          }
        // Delete
        case 'Delete':
          {
            (0, _handleCellDeletion.handleCellDeletion)(deleteParams);
            break;
          }
        // Enter
        case 'Enter':
          {
            (0, _handleActiveCellInSelectionEnter.handleActiveCellInSelectionEnter)({
              activeCellInsideSelectionArea: activeCellInsideSelectionArea,
              activeCellCoordinates: activeCellCoordinates,
              activeCellRef: activeCellRef,
              selectionAreas: selectionAreas,
              updateActiveCellCoordinates: updateActiveCellCoordinates
            });
            break;
          }
        // HOME
        case 'Home':
          {
            if ((0, _handleMultipleKeys.includesResourceKey)(keysPressedList, usingMac)) {
              return;
            }
            handleHomeEndKey({
              type: 'home'
            });
            break;
          }
        case 'End':
          {
            if ((0, _handleMultipleKeys.includesResourceKey)(keysPressedList, usingMac)) {
              return;
            }
            handleHomeEndKey({
              type: 'end'
            });
            break;
          }
        // Tab
        case 'Tab':
          {
            if (activeCellInsideSelectionArea) {
              event.preventDefault();
              return (0, _handleActiveCellInSelectionTab.handleActiveCellInSelectionTab)({
                activeCellInsideSelectionArea: activeCellInsideSelectionArea,
                activeCellCoordinates: activeCellCoordinates,
                activeCellRef: activeCellRef,
                selectionAreas: selectionAreas,
                updateActiveCellCoordinates: updateActiveCellCoordinates
              });
            }
            setSelectionAreas([]);
            removeActiveCell();
            removeCellEditor();
            setContainerHasFocus(false);
            setActiveCellCoordinates(null);
            break;
          }
        // Left
        case 'ArrowLeft':
          {
            handleInitialArrowPress();
            var coordinatesClone = _objectSpread({}, activeCellCoordinates);
            if (coordinatesClone.column === 'header') {
              return;
            }
            if (typeof coordinatesClone.column === 'number') {
              if (coordinatesClone.column === 0) {
                updateActiveCellCoordinates({
                  coords: coordinatesClone,
                  updatedValue: {
                    column: 'header'
                  }
                });
                return;
              }
              updateActiveCellCoordinates({
                coords: coordinatesClone,
                updatedValue: {
                  column: coordinatesClone.column - 1
                }
              });
            }
            break;
          }
        // Up
        case 'ArrowUp':
          {
            handleInitialArrowPress();
            var _coordinatesClone = _objectSpread({}, activeCellCoordinates);
            if (_coordinatesClone.row === 'header') {
              return;
            }
            if (typeof _coordinatesClone.row === 'number') {
              // set row back to header if we are at index 0
              if (_coordinatesClone.row === 0) {
                updateActiveCellCoordinates({
                  coords: _coordinatesClone,
                  updatedValue: {
                    row: 'header'
                  }
                });
                return;
              }
              // if we are at any other index than 0, subtract 1 from current row index
              updateActiveCellCoordinates({
                coords: _coordinatesClone,
                updatedValue: {
                  row: _coordinatesClone.row - 1
                }
              });
            }
            break;
          }
        // Right
        case 'ArrowRight':
          {
            handleInitialArrowPress();
            var _coordinatesClone2 = _objectSpread({}, activeCellCoordinates);
            if (_coordinatesClone2.column === 'header') {
              updateActiveCellCoordinates({
                coords: _coordinatesClone2,
                updatedValue: {
                  column: 0
                }
              });
            }
            if (typeof _coordinatesClone2.column === 'number') {
              // Prevent active cell coordinates from updating if the active
              // cell is in the last column, ie we can't go any further to the right
              if (columns.length - 1 === _coordinatesClone2.column) {
                return;
              }
              updateActiveCellCoordinates({
                coords: _coordinatesClone2,
                updatedValue: {
                  column: _coordinatesClone2.column + 1
                }
              });
            }
            break;
          }
        // Down
        case 'ArrowDown':
          {
            handleInitialArrowPress();
            var _coordinatesClone3 = _objectSpread({}, activeCellCoordinates);
            if (_coordinatesClone3.row === 'header') {
              updateActiveCellCoordinates({
                coords: _coordinatesClone3,
                updatedValue: {
                  row: 0
                }
              });
            }
            if (typeof _coordinatesClone3.row === 'number') {
              // Prevent active cell coordinates from updating if the active
              // cell is in the last row, ie we can't go any further down since
              // we are in the last row
              if (rows.length - 1 === _coordinatesClone3.row) {
                return;
              }
              updateActiveCellCoordinates({
                coords: _coordinatesClone3,
                updatedValue: {
                  row: _coordinatesClone3.row + 1
                }
              });
            }
            break;
          }
      }
    }
  }, [activeCellInsideSelectionArea, updateActiveCellCoordinates, handleInitialArrowPress, activeCellCoordinates, removeActiveCell, columns, rows, spreadsheetRef, currentMatcher, isEditing, removeCellEditor, selectionAreas, handleHomeEndKey, keysPressedList, usingMac, updateData]);
  var startEditMode = function startEditMode() {
    setIsEditing(true);
    setClickAndHoldActive(false);
    var activeCellFullData = typeof (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) === 'number' && typeof (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'number' ? rows[activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row].cells[activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column] : null;
    var activeCellValue = activeCellFullData ? activeCellFullData.row.cells[activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column].value : null;
    setCellEditorValue(activeCellValue);
    cellEditorRulerRef.current.textContent = activeCellValue;
    cellEditorRef.current.style.width = activeCellRef === null || activeCellRef === void 0 ? void 0 : activeCellRef.current.style.width;
  };

  // Sets the initial placement of the cell editor cursor at the end of the text area
  // this is not done for us by default in Safari
  (0, _react.useEffect)(function () {
    if (isEditing && !(previousState !== null && previousState !== void 0 && previousState.isEditing)) {
      cellEditorRef.current.setSelectionRange(cellEditorRulerRef.current.textContent.length, cellEditorRulerRef.current.textContent.length);
      cellEditorRef.current.focus();
    }
  }, [isEditing, previousState === null || previousState === void 0 ? void 0 : previousState.isEditing]);
  var handleActiveCellClick = function handleActiveCellClick() {
    if ((activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'header' || (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) === 'header') {
      var indexValue = (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'header' ? activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column : activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row;
      if ((activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'header' && (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) === 'header') {
        return;
      }
      handleRowColumnHeaderClick({
        isKeyboard: false,
        index: indexValue
      });
    }
    return;
  };

  // Mouse up on active cell
  var handleActiveCellMouseUp = function handleActiveCellMouseUp() {
    setClickAndHoldActive(false);
  };

  // Mouse down on active cell
  var handleActiveCellMouseDown = function handleActiveCellMouseDown() {
    if ((activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) !== 'header' || (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) !== 'header') {
      var tempMatcher = (0, _uuidv.default)();
      setClickAndHoldActive(true);
      (0, _removeCellSelections.removeCellSelections)({
        spreadsheetRef: spreadsheetRef
      });
      setSelectionAreas([{
        point1: activeCellCoordinates,
        matcher: tempMatcher
      }]);
      setCurrentMatcher(tempMatcher);
      setSelectionAreaData([]);
      setActiveCellInsideSelectionArea(false);
    }
    return;
  };

  // Go into edit mode if 'Enter' key is pressed on activeCellRef
  var handleActiveCellKeyDown = function handleActiveCellKeyDown(event) {
    var key = event.key;
    if (key === 'Enter' && !activeCellInsideSelectionArea) {
      if ((activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) !== 'header' && (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) !== 'header') {
        startEditMode();
      }
      if ((activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'header' || (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) === 'header') {
        handleRowColumnHeaderClick({
          isKeyboard: true
        });
      }
    }
  };
  var handleRowColumnHeaderClick = function handleRowColumnHeaderClick(_ref5) {
    var isKeyboard = _ref5.isKeyboard,
      _ref5$index = _ref5.index,
      index = _ref5$index === void 0 ? null : _ref5$index;
    var handleHeaderCellProps = {
      activeCellCoordinates: activeCellCoordinates,
      rows: rows,
      columns: columns,
      setActiveCellCoordinates: setActiveCellCoordinates,
      setCurrentMatcher: setCurrentMatcher,
      setSelectionAreas: setSelectionAreas,
      spreadsheetRef: spreadsheetRef,
      isKeyboard: isKeyboard,
      setSelectionAreaData: setSelectionAreaData,
      index: index,
      currentMatcher: currentMatcher
    };
    // Select an entire column
    if ((activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'header' && (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) !== 'header') {
      (0, _handleHeaderCellSelection.handleHeaderCellSelection)(_objectSpread({
        type: 'column'
      }, handleHeaderCellProps));
    }
    // Select an entire row
    if ((activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) === 'header' && (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) !== 'header') {
      (0, _handleHeaderCellSelection.handleHeaderCellSelection)(_objectSpread({
        type: 'row'
      }, handleHeaderCellProps));
    }
    if ((activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) === 'header' && (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'header') {
      (0, _selectAllCells.selectAllCells)({
        ref: spreadsheetRef,
        setCurrentMatcher: setCurrentMatcher,
        setSelectionAreas: setSelectionAreas,
        rows: rows,
        columns: columns,
        activeCellCoordinates: activeCellCoordinates,
        updateActiveCellCoordinates: updateActiveCellCoordinates
      });
    }
  };

  // Go into edit mode if double click is detected on activeCellRef
  var handleActiveCellDoubleClick = function handleActiveCellDoubleClick() {
    startEditMode();
  };
  (0, _hooks2.useSpreadsheetEdit)({
    isEditing: isEditing,
    rows: rows,
    activeCellCoordinates: activeCellCoordinates,
    activeCellRef: activeCellRef,
    cellEditorRef: cellEditorRef,
    cellEditorRulerRef: cellEditorRulerRef,
    visibleColumns: visibleColumns,
    defaultColumn: defaultColumn,
    cellEditorValue: cellEditorValue
  });

  // Only update if there are cell selection areas
  // Find point object that matches currentMatcher and remove the second point
  // because hovering over the active cell while clicking and holding should
  // remove the previously existing selection area
  var handleActiveCellMouseEnterCallback = (0, _react.useCallback)(function (areas, clickHold) {
    if (!currentMatcher) {
      return;
    }
    if (areas && areas.length && clickHold && currentMatcher) {
      setSelectionAreas(function (prev) {
        var selectionAreaClone = (0, _deepCloneObject.deepCloneObject)(prev);
        var indexOfItemToUpdate = selectionAreaClone.findIndex(function (item) {
          return item.matcher === currentMatcher;
        });
        if (indexOfItemToUpdate === -1) {
          return prev;
        }
        if ((0, _typeof2.default)(selectionAreaClone[indexOfItemToUpdate].point2) === 'object' && selectionAreaClone[indexOfItemToUpdate].areaCreated) {
          selectionAreaClone[indexOfItemToUpdate].point2 = selectionAreaClone[indexOfItemToUpdate].point1;
          selectionAreaClone[indexOfItemToUpdate].areaCreated = false;
          setActiveCellInsideSelectionArea(false);
          (0, _removeCellSelections.removeCellSelections)({
            matcher: currentMatcher,
            spreadsheetRef: spreadsheetRef
          });
          return selectionAreaClone;
        }
        return prev;
      });
    }
  }, [spreadsheetRef, currentMatcher]);
  var handleActiveCellMouseEnter = (0, _react.useCallback)(function () {
    handleActiveCellMouseEnterCallback(selectionAreas, clickAndHoldActive);
  }, [clickAndHoldActive, selectionAreas, handleActiveCellMouseEnterCallback]);
  return /*#__PURE__*/_react.default.createElement("div", (0, _extends2.default)({}, rest, getTableProps(), (0, _devtools.getDevtoolsProps)(componentName), {
    className: (0, _classnames.default)(blockClass, className, "".concat(blockClass, "--interactive-cell-element"), (_cx = {}, (0, _defineProperty2.default)(_cx, "".concat(blockClass, "__container-has-focus"), containerHasFocus), (0, _defineProperty2.default)(_cx, "".concat(blockClass, "__").concat(theme), theme === 'dark'), _cx)),
    ref: spreadsheetRef,
    role: "grid",
    tabIndex: 0,
    "aria-rowcount": (rows === null || rows === void 0 ? void 0 : rows.length) || 0,
    "aria-colcount": (columns === null || columns === void 0 ? void 0 : columns.length) || 0,
    "aria-label": spreadsheetAriaLabel,
    onKeyDown: handleKeyPress,
    onFocus: function onFocus() {
      return setContainerHasFocus(true);
    }
  }), /*#__PURE__*/_react.default.createElement("div", {
    ref: multiKeyTrackingRef
  }, /*#__PURE__*/_react.default.createElement(_DataSpreadsheetHeader.DataSpreadsheetHeader, {
    ref: spreadsheetRef,
    activeCellCoordinates: activeCellCoordinates,
    cellSize: cellSize,
    columns: columns,
    currentMatcher: currentMatcher,
    defaultColumn: defaultColumn,
    headerGroups: headerGroups,
    rows: rows,
    scrollBarSize: scrollBarSize,
    selectionAreas: selectionAreas,
    setActiveCellCoordinates: setActiveCellCoordinates,
    setSelectionAreas: setSelectionAreas,
    setCurrentMatcher: setCurrentMatcher,
    setSelectionAreaData: setSelectionAreaData,
    totalVisibleColumns: totalVisibleColumns,
    updateActiveCellCoordinates: updateActiveCellCoordinates,
    setHeaderCellHoldActive: setHeaderCellHoldActive,
    headerCellHoldActive: headerCellHoldActive,
    visibleColumns: visibleColumns,
    selectAllAriaLabel: selectAllAriaLabel
  }), /*#__PURE__*/_react.default.createElement(_DataSpreadsheetBody.DataSpreadsheetBody, {
    activeCellCoordinates: activeCellCoordinates,
    ref: spreadsheetRef,
    clickAndHoldActive: clickAndHoldActive,
    setClickAndHoldActive: setClickAndHoldActive,
    currentMatcher: currentMatcher,
    setCurrentMatcher: setCurrentMatcher,
    setContainerHasFocus: setContainerHasFocus,
    selectionAreas: selectionAreas,
    setSelectionAreas: setSelectionAreas,
    cellSize: cellSize,
    headerGroups: headerGroups,
    defaultColumn: defaultColumn,
    getTableBodyProps: getTableBodyProps,
    onDataUpdate: onDataUpdate,
    onActiveCellChange: onActiveCellChange,
    onSelectionAreaChange: onSelectionAreaChange,
    prepareRow: prepareRow,
    rows: rows,
    selectionAreaData: selectionAreaData,
    setSelectionAreaData: setSelectionAreaData,
    setActiveCellCoordinates: setActiveCellCoordinates,
    scrollBarSize: scrollBarSize,
    totalColumnsWidth: totalColumnsWidth,
    id: id,
    columns: columns,
    defaultEmptyRowCount: defaultEmptyRowCount,
    setActiveCellInsideSelectionArea: setActiveCellInsideSelectionArea,
    totalVisibleColumns: totalVisibleColumns,
    setHeaderCellHoldActive: setHeaderCellHoldActive,
    setColumnOrder: setColumnOrder,
    visibleColumns: visibleColumns
  }), /*#__PURE__*/_react.default.createElement("button", {
    onMouseDown: handleActiveCellMouseDown,
    onMouseUp: handleActiveCellMouseUp,
    onClick: handleActiveCellClick,
    onKeyDown: handleActiveCellKeyDown,
    onDoubleClick: handleActiveCellDoubleClick,
    onMouseEnter: handleActiveCellMouseEnter,
    ref: activeCellRef,
    className: (0, _classnames.default)("".concat(blockClass, "--interactive-cell-element"), "".concat(blockClass, "__active-cell--highlight"), (0, _defineProperty2.default)({}, "".concat(blockClass, "__active-cell--with-selection"), activeCellInsideSelectionArea)),
    type: "button"
  }, activeCellContent), /*#__PURE__*/_react.default.createElement("textarea", {
    id: "".concat(blockClass, "__cell-editor-text-area"),
    value: cellEditorValue,
    onKeyDown: (0, _handleEditSubmit.handleEditSubmit)({
      activeCellCoordinates: activeCellCoordinates,
      cellEditorRulerRef: cellEditorRulerRef,
      columns: columns,
      previousState: previousState,
      removeCellEditor: removeCellEditor,
      rows: rows,
      setActiveCellCoordinates: setActiveCellCoordinates,
      setCurrentMatcher: setCurrentMatcher,
      setSelectionAreas: setSelectionAreas,
      spreadsheetRef: spreadsheetRef,
      updateData: updateData
    }),
    onChange: function onChange(event) {
      setCellEditorValue(event.target.value);
      cellEditorRulerRef.current.textContent = event.target.value;
    },
    ref: cellEditorRef,
    "aria-labelledby": activeCellCoordinates ? "".concat(blockClass, "__cell--").concat(activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row, "--").concat(activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) : null,
    className: (0, _classnames.default)("".concat(blockClass, "__cell-editor"), "".concat(blockClass, "--interactive-cell-element"), "".concat(blockClass, "__cell-editor--").concat(cellSize), (0, _defineProperty2.default)({}, "".concat(blockClass, "__cell-editor--active"), isEditing))
  }), /*#__PURE__*/_react.default.createElement("pre", {
    "aria-hidden": true,
    ref: cellEditorRulerRef,
    className: "".concat(blockClass, "__cell-editor-ruler")
  })));
});

// Return a placeholder if not released and not enabled by feature flag
exports.DataSpreadsheet = DataSpreadsheet;
exports.DataSpreadsheet = DataSpreadsheet = _settings.pkg.checkComponentEnabled(DataSpreadsheet, componentName);

// The display name of the component, used by React. Note that displayName
// is used in preference to relying on function.name.
DataSpreadsheet.displayName = componentName;

// The types and DocGen commentary for the component props,
// in alphabetical order (for consistency).
// See https://www.npmjs.com/package/prop-types#usage.
DataSpreadsheet.propTypes = {
  /**
   * Specifies the cell height
   */
  cellSize: _propTypes.default.oneOf(['xs', 'sm', 'md', 'lg']),
  /**
   * Provide an optional class to be applied to the containing node.
   */
  className: _propTypes.default.string,
  /**
   * The data that will build the column headers
   */
  columns: _propTypes.default.arrayOf(_propTypes.default.shape({
    Header: _propTypes.default.string,
    accessor: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func]),
    Cell: _propTypes.default.func // optional cell formatter
  })),

  /**
   * The spreadsheet data that will be rendered in the body of the spreadsheet component
   */
  data: _propTypes.default.arrayOf(_propTypes.default.shape),
  /**
   * Sets the number of empty rows to be created when there is no data provided
   */
  defaultEmptyRowCount: _propTypes.default.number,
  /**
   * The spreadsheet id
   */
  id: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
  /**
   * The event handler that is called when the active cell changes
   */
  onActiveCellChange: _propTypes.default.func,
  /**
   * The setter fn for the data prop
   */
  onDataUpdate: _propTypes.default.func,
  /**
   * The event handler that is called when the selection area values change
   */
  onSelectionAreaChange: _propTypes.default.func,
  /**
   * The aria label applied to the Select all button
   */
  selectAllAriaLabel: _propTypes.default.string.isRequired,
  /**
   * The aria label applied to the Data spreadsheet component
   */
  spreadsheetAriaLabel: _propTypes.default.string.isRequired,
  /**
   * The theme the DataSpreadsheet should use (only used to render active cell/selection area colors on dark theme)
   */
  theme: _propTypes.default.oneOf(['light', 'dark']),
  /**
   * The total number of columns to be initially visible, additional columns will be rendered and
   * visible via horizontal scrollbar
   */
  totalVisibleColumns: _propTypes.default.number

  /* TODO: add types and DocGen for all props. */
};