"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSpreadsheetEdit = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = require("react");
var _layout = require("@carbon/layout");
var _settings = require("../../../settings");
var _hooks = require("../../../global/js/hooks");
/**
 * Copyright IBM Corp. 2022, 2022
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

var useSpreadsheetEdit = function useSpreadsheetEdit(_ref) {
  var isEditing = _ref.isEditing,
    rows = _ref.rows,
    activeCellCoordinates = _ref.activeCellCoordinates,
    activeCellRef = _ref.activeCellRef,
    cellEditorRef = _ref.cellEditorRef,
    cellEditorRulerRef = _ref.cellEditorRulerRef,
    visibleColumns = _ref.visibleColumns,
    defaultColumn = _ref.defaultColumn,
    cellEditorValue = _ref.cellEditorValue,
    _ref$blockClass = _ref.blockClass,
    blockClass = _ref$blockClass === void 0 ? "".concat(_settings.pkg.prefix, "--data-spreadsheet") : _ref$blockClass;
  var _useState = (0, _react.useState)(null),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    nextIndex = _useState2[0],
    setNextIndex = _useState2[1];
  var previousState = (0, _hooks.usePreviousValue)({
    nextIndex: nextIndex
  });
  (0, _react.useEffect)(function () {
    if (!(previousState !== null && previousState !== void 0 && previousState.nextIndex)) {
      setNextIndex(activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column);
    }
  }, [previousState === null || previousState === void 0 ? void 0 : previousState.nextIndex, activeCellCoordinates]);
  (0, _react.useEffect)(function () {
    var rulerWidth = cellEditorRulerRef.current.offsetWidth;
    var cellEditorCurrentWidth = parseInt(cellEditorRef.current.style.width);
    if (isEditing) {
      var _rows$activeCellCoord, _cellProps$column, _cellEditorRef$curren;
      var cellProps = (_rows$activeCellCoord = rows[activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row]) === null || _rows$activeCellCoord === void 0 ? void 0 : _rows$activeCellCoord.cells[activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column];
      var activeCellLeftPosition = activeCellRef === null || activeCellRef === void 0 ? void 0 : activeCellRef.current.style.left;
      var activeCellTopPosition = activeCellRef === null || activeCellRef === void 0 ? void 0 : activeCellRef.current.style.top;
      cellEditorRef.current.style.left = activeCellLeftPosition;
      cellEditorRef.current.style.top = activeCellTopPosition;
      cellEditorRef.current.style.display = 'block';
      cellEditorRef.current.style.height = activeCellRef === null || activeCellRef === void 0 ? void 0 : activeCellRef.current.style.height;
      cellEditorRef.current.style.paddingTop = "".concat((parseInt(activeCellRef === null || activeCellRef === void 0 ? void 0 : activeCellRef.current.style.height) - 16) / 2 - 1, "px"); // calculate paddingTop based on cellHeight which could be variable depending on the cellSize prop
      cellEditorRef.current.style.textAlign = (cellProps === null || cellProps === void 0 ? void 0 : (_cellProps$column = cellProps.column) === null || _cellProps$column === void 0 ? void 0 : _cellProps$column.placement) === 'right' ? 'right' : 'left';
      (_cellEditorRef$curren = cellEditorRef.current) === null || _cellEditorRef$curren === void 0 ? void 0 : _cellEditorRef$curren.focus();
      if (rulerWidth < cellEditorCurrentWidth) {
        var _visibleColumns$nextI;
        var currentColumnWidth = ((_visibleColumns$nextI = visibleColumns[nextIndex]) === null || _visibleColumns$nextI === void 0 ? void 0 : _visibleColumns$nextI.width) || (defaultColumn === null || defaultColumn === void 0 ? void 0 : defaultColumn.width);
        // If the contents of the cell editor is deleted past the point of the next column
        if (rulerWidth < cellEditorCurrentWidth - currentColumnWidth) {
          cellEditorRef.current.style.width = (0, _layout.px)(parseInt(cellEditorRef.current.style.width) - currentColumnWidth);
          setNextIndex(function (prev) {
            if (prev === 0) {
              return prev;
            }
            return prev - 1;
          });
        }
        // Decrease cell editor width by increment of current column width
      }

      if (rulerWidth >= cellEditorCurrentWidth) {
        var _visibleColumns;
        setNextIndex(function (prev) {
          if (prev === visibleColumns.length - 1) {
            return prev;
          }
          return prev + 1;
        });
        var onLastColumnIndex = nextIndex + 1 === visibleColumns.length;
        var nextColumnWidth = onLastColumnIndex ? 0 : ((_visibleColumns = visibleColumns[nextIndex + 1]) === null || _visibleColumns === void 0 ? void 0 : _visibleColumns.width) || (defaultColumn === null || defaultColumn === void 0 ? void 0 : defaultColumn.width);
        var startingRowPosition = activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row;
        var totalRows = rows.length;
        var totalCellEditorMaxHeight = (totalRows - startingRowPosition) * defaultColumn.rowHeight;
        cellEditorRef.current.style.maxHeight = (0, _layout.px)(totalCellEditorMaxHeight);
        cellEditorRef.current.style.width = (0, _layout.px)(nextColumnWidth + cellEditorCurrentWidth);
        cellEditorRef.current.style.height = (0, _layout.px)(cellEditorRef.current.scrollHeight); // adds dynamic height to cell editor
        // Cell editor has reached max height, we need to add the scrolling back.
        // We also need to subtract 1 to account for the fact that the cell editor
        // is placed one pixel below the cell being edited to account for the border
        if (cellEditorRef.current.clientHeight === totalCellEditorMaxHeight - 1) {
          cellEditorRef.current.style.overflow = 'auto';
        } else {
          cellEditorRef.current.style.overflow = 'hidden';
        }
      }
    }
    if (!isEditing) {
      cellEditorRef.current.style.overflow = 'hidden';
      cellEditorRef.current.style.display = 'none';
      cellEditorRef.current.blur();
      activeCellRef.current.focus();
      setNextIndex(activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column);
    }
  }, [isEditing, activeCellCoordinates, rows, cellEditorValue, defaultColumn, activeCellRef, cellEditorRef, cellEditorRulerRef, visibleColumns, blockClass, previousState === null || previousState === void 0 ? void 0 : previousState.cellEditorValue, nextIndex]);
};
exports.useSpreadsheetEdit = useSpreadsheetEdit;