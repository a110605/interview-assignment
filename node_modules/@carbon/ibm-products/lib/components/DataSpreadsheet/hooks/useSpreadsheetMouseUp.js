"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSpreadsheetMouseUp = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _react = require("react");
var _layout = require("@carbon/layout");
var _settings = require("../../../settings");
var _deepCloneObject = require("../../../global/js/utils/deepCloneObject");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright IBM Corp. 2022, 2022
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the Apache-2.0 license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */
var useSpreadsheetMouseUp = function useSpreadsheetMouseUp(_ref) {
  var currentMatcher = _ref.currentMatcher,
    setSelectionAreas = _ref.setSelectionAreas,
    setClickAndHoldActive = _ref.setClickAndHoldActive,
    setValidStartingPoint = _ref.setValidStartingPoint,
    validStartingPoint = _ref.validStartingPoint,
    _ref$blockClass = _ref.blockClass,
    blockClass = _ref$blockClass === void 0 ? "".concat(_settings.pkg.prefix, "--data-spreadsheet") : _ref$blockClass,
    ref = _ref.ref,
    setHeaderCellHoldActive = _ref.setHeaderCellHoldActive,
    setColumnOrder = _ref.setColumnOrder,
    visibleColumns = _ref.visibleColumns,
    setActiveCellCoordinates = _ref.setActiveCellCoordinates,
    activeCellCoordinates = _ref.activeCellCoordinates,
    rows = _ref.rows,
    defaultColumn = _ref.defaultColumn,
    selectionAreas = _ref.selectionAreas;
  (0, _react.useEffect)(function () {
    var handleMouseUp = function handleMouseUp(event) {
      // Remove the cloned selection area on mouse up
      if (!validStartingPoint) {
        setHeaderCellHoldActive(false);
        var selectionAreaCloneElement = ref.current.querySelector(".".concat(blockClass, "__selection-area--element-cloned"));
        if (!selectionAreaCloneElement) {
          return;
        }
        // Mouse up while a cloned selection area exists/a column is being reordered
        if (selectionAreaCloneElement) {
          var closestCell = event.target.closest(".".concat(blockClass, "--interactive-cell-element"));
          var newColumnIndex = parseInt === null || parseInt === void 0 ? void 0 : parseInt(closestCell === null || closestCell === void 0 ? void 0 : closestCell.getAttribute('data-column-index'));
          var originalColumnIndex = parseInt === null || parseInt === void 0 ? void 0 : parseInt(selectionAreaCloneElement === null || selectionAreaCloneElement === void 0 ? void 0 : selectionAreaCloneElement.getAttribute('data-column-index-original'));
          var selectionAreaToClone = selectionAreas.filter(function (item) {
            return (item === null || item === void 0 ? void 0 : item.matcher) === currentMatcher;
          });
          var selectionAreaIndexArray = selectionAreaToClone[0].header.selectedIndexList;
          var columnToMoveToElement = ref.current.querySelector("[data-row-index=\"header\"][data-column-index=\"".concat(newColumnIndex, "\"]"));
          // Mouse up element was not part of the spreadsheet component
          if (!columnToMoveToElement) {
            return;
          }
          var selectionAreaToMove = ref.current.querySelector("[data-matcher-id=\"".concat(currentMatcher, "\"]"));
          var spreadsheetPosition = ref.current.getBoundingClientRect();
          var listContainer = ref.current.querySelector(".".concat(blockClass, "__list--container"));
          var leftScrollAmount = listContainer.scrollLeft;
          var newIndexLessThanStarting = newColumnIndex < originalColumnIndex;
          var newIndexGreater = newColumnIndex > originalColumnIndex;
          var differenceBetweenOldNewIndex = newIndexGreater ? newColumnIndex - originalColumnIndex : originalColumnIndex - newColumnIndex;
          setSelectionAreas(function (prev) {
            var selectionAreaClone = (0, _deepCloneObject.deepCloneObject)(prev);
            if (originalColumnIndex === newColumnIndex) {
              return prev;
            }
            var indexOfItemToUpdate = selectionAreaClone.findIndex(function (item) {
              return item.matcher === currentMatcher;
            });
            if (indexOfItemToUpdate === -1) {
              return prev;
            }
            if (!selectionAreaIndexArray.includes(newColumnIndex)) {
              // We need to not add just the newColumnIndex, but an array of indexes
              // if there are multiple columns
              var newIndexArray = newIndexGreater ? selectionAreaIndexArray.map(function (num) {
                return num + differenceBetweenOldNewIndex;
              }) : selectionAreaIndexArray.map(function (num) {
                return num - differenceBetweenOldNewIndex;
              });
              selectionAreaClone[indexOfItemToUpdate].header.selectedIndexList = newIndexArray;
              selectionAreaClone[indexOfItemToUpdate].point1.column = Math.min.apply(Math, (0, _toConsumableArray2.default)(newIndexArray));
              selectionAreaClone[indexOfItemToUpdate].point2.column = Math.max.apply(Math, (0, _toConsumableArray2.default)(newIndexArray));
            }
            return selectionAreaClone;
          });
          // Only reorder columns if the new index is _not_ part of the
          // selectionAreaIndexArray, meaning the new placement is outside
          // of the current selection area. Similarly, the active cell position
          // should only be changed under the same condition.
          if (!selectionAreaIndexArray.includes(newColumnIndex)) {
            var deleteCount = selectionAreaIndexArray.length;
            var startIndex = Math.min.apply(Math, (0, _toConsumableArray2.default)(selectionAreaIndexArray));
            var columnIdArray = visibleColumns.map(function (column) {
              return column.id;
            });
            var columnIdArrayClone = (0, _toConsumableArray2.default)(columnIdArray);
            var getNewColumnOrder = function getNewColumnOrder() {
              var newColumnList = [];
              selectionAreaIndexArray.map(function (index) {
                return newColumnList.push(columnIdArray[index]);
              });
              return newColumnList;
            };
            // Remove one element at the original index
            columnIdArrayClone.splice(startIndex, deleteCount);
            var originalPointIndex = selectionAreaIndexArray.findIndex(function (item) {
              return item === originalColumnIndex;
            });
            var updatedNewIndexWithNewOrder = newColumnIndex - originalPointIndex;
            // Add one element at the new index
            columnIdArrayClone.splice.apply(columnIdArrayClone, [updatedNewIndexWithNewOrder, 0].concat((0, _toConsumableArray2.default)(getNewColumnOrder())));
            setColumnOrder(columnIdArrayClone); // Function provided by useTable (react-table) hook to reorder columns
            var newCellCoords = _objectSpread(_objectSpread({}, activeCellCoordinates), {}, {
              column: newIndexGreater ? activeCellCoordinates.column + differenceBetweenOldNewIndex : activeCellCoordinates.column - differenceBetweenOldNewIndex
            });
            setActiveCellCoordinates(newCellCoords);
            var firstSelectedHeader = Array.from(ref.current.querySelectorAll(".".concat(blockClass, "__th--selected-header")))[0];
            var firstSelectedHeaderCoords = firstSelectedHeader.getBoundingClientRect();
            var newRelativePosition = firstSelectedHeaderCoords.left - spreadsheetPosition.left + leftScrollAmount;
            // console.log(firstSelectedHeaderCoords.left - spreadsheetPosition.left + leftScrollAmount);
            var updatedSelectionAreaPlacement = newIndexLessThanStarting ? newRelativePosition : newColumnIndex === originalColumnIndex ? selectionAreaToMove.style.left : newRelativePosition;
            selectionAreaToMove.style.left = (0, _layout.px)(updatedSelectionAreaPlacement);
          }
          // Remove the cloned column and indicator elements
          var indicatorLineElement = ref.current.querySelector(".".concat(blockClass, "__reorder-indicator-line"));
          indicatorLineElement === null || indicatorLineElement === void 0 ? void 0 : indicatorLineElement.remove();
          selectionAreaCloneElement === null || selectionAreaCloneElement === void 0 ? void 0 : selectionAreaCloneElement.remove();
        }
      }
      // Mouse up was on a spreadsheet body cell which is a valid
      // start/end point for creating a selection area
      if (validStartingPoint) {
        setClickAndHoldActive(false);
        setValidStartingPoint(false);
        var cellButton = event.target.closest(".".concat(blockClass, "__body--td"));
        if (cellButton) {
          var endCellCoordinates = {
            row: Number(cellButton.getAttribute('data-row-index')),
            column: Number(cellButton.getAttribute('data-column-index'))
          };
          setSelectionAreas(function (prev) {
            var selectionAreaClone = (0, _deepCloneObject.deepCloneObject)(prev);
            var indexOfItemToUpdate = selectionAreaClone.findIndex(function (item) {
              return item.matcher === currentMatcher;
            });
            // No items in the array have an object that matches the value of currentMatcher
            if (indexOfItemToUpdate === -1) {
              return prev;
            }
            selectionAreaClone[indexOfItemToUpdate].point2 = endCellCoordinates;
            selectionAreaClone[indexOfItemToUpdate].areaCreated = false;
            return selectionAreaClone;
          });
        }
      }
    };
    document.addEventListener('mouseup', handleMouseUp);
    return function () {
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [blockClass, currentMatcher, setSelectionAreas, setClickAndHoldActive, setValidStartingPoint, validStartingPoint, ref, setHeaderCellHoldActive, setColumnOrder, visibleColumns, setActiveCellCoordinates, activeCellCoordinates, rows, defaultColumn, selectionAreas]);
};
exports.useSpreadsheetMouseUp = useSpreadsheetMouseUp;