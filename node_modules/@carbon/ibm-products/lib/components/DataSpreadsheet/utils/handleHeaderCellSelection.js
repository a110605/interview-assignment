"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleHeaderCellSelection = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _deepCloneObject = require("../../../global/js/utils/deepCloneObject");
var _uuidv = _interopRequireDefault(require("../../../global/js/utils/uuidv4"));
var _removeCellSelections = require("./removeCellSelections");
var _checkActiveHeaderCell = require("./checkActiveHeaderCell");
/**
 * Copyright IBM Corp. 2022, 2022
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

var getSelectedItemIndexList = function getSelectedItemIndexList(_ref) {
  var indexList = _ref.indexList,
    newIndex = _ref.newIndex,
    activeCellIndex = _ref.activeCellIndex;
  var lowestIndex = newIndex > activeCellIndex ? activeCellIndex : Math.min.apply(Math, (0, _toConsumableArray2.default)(indexList).concat([newIndex]));
  var highestIndex = newIndex < activeCellIndex ? activeCellIndex : Math.max.apply(Math, (0, _toConsumableArray2.default)(indexList).concat([newIndex]));
  var newIndexList = [];
  for (var i = lowestIndex; i <= highestIndex; i++) {
    newIndexList.push(i);
  }
  return [].concat(newIndexList);
};
var handleHeaderCellSelection = function handleHeaderCellSelection(_ref2) {
  var type = _ref2.type,
    activeCellCoordinates = _ref2.activeCellCoordinates,
    rows = _ref2.rows,
    columns = _ref2.columns,
    currentMatcher = _ref2.currentMatcher,
    setActiveCellCoordinates = _ref2.setActiveCellCoordinates,
    setCurrentMatcher = _ref2.setCurrentMatcher,
    setSelectionAreas = _ref2.setSelectionAreas,
    spreadsheetRef = _ref2.spreadsheetRef,
    index = _ref2.index,
    isKeyboard = _ref2.isKeyboard,
    setSelectionAreaData = _ref2.setSelectionAreaData,
    isHoldingCommandKey = _ref2.isHoldingCommandKey,
    isHoldingShiftKey = _ref2.isHoldingShiftKey;
  if (!isHoldingCommandKey) {
    setSelectionAreaData([]);
    (0, _removeCellSelections.removeCellSelections)({
      spreadsheetRef: spreadsheetRef
    });
  }
  var rowValue = isKeyboard ? activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row : index;
  var columnValue = isKeyboard ? activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column : index;
  var point1 = {
    row: type === 'column' ? 0 : rowValue,
    column: type === 'column' ? columnValue : 0
  };
  var point2 = {
    row: type === 'column' ? rows.length - 1 : rowValue,
    // going to always be the last row
    column: type === 'column' ? columnValue : columns.length - 1
  };
  var tempMatcher = (0, _uuidv.default)();
  if (!isHoldingShiftKey) {
    setActiveCellCoordinates({
      row: type === 'column' ? 0 : rowValue,
      column: type === 'column' ? columnValue : 0
    });
    setCurrentMatcher(tempMatcher);
  }
  var newSelectionArea = {
    point1: point1,
    point2: point2,
    areaCreated: false,
    matcher: tempMatcher,
    header: {
      type: type,
      selectedIndexList: [type === 'column' ? columnValue : rowValue]
    }
  };
  setSelectionAreas(function (prev) {
    var selectionsClone = (0, _deepCloneObject.deepCloneObject)(prev);
    if (isHoldingCommandKey) {
      var selectionsFromHeaderCell = selectionsClone.filter(function (item) {
        var _item$header;
        return (_item$header = item.header) === null || _item$header === void 0 ? void 0 : _item$header.type;
      });
      var previouslyCreatedHeaderSelection = selectionsFromHeaderCell.filter(function (item) {
        var _item$header2;
        return ((_item$header2 = item.header) === null || _item$header2 === void 0 ? void 0 : _item$header2.type) === type;
      });
      var isHeaderPartOfPreviousSelection = (0, _checkActiveHeaderCell.checkActiveHeaderCell)(index, previouslyCreatedHeaderSelection, type);
      // Prevents row/column header selections from being created multiple times
      if (previouslyCreatedHeaderSelection.length && isHeaderPartOfPreviousSelection) {
        return prev;
      }
      return [].concat((0, _toConsumableArray2.default)(prev), [newSelectionArea]);
    }
    if (isHoldingShiftKey) {
      var _selectionAreasClone$, _selectionAreasClone$2;
      var _selectionsFromHeaderCell = selectionsClone.filter(function (item) {
        var _item$header3;
        return (_item$header3 = item.header) === null || _item$header3 === void 0 ? void 0 : _item$header3.type;
      });
      // Shift/click behavior should not occur unless there are activeCellCoordinates set
      var currentSelectionArea = _selectionsFromHeaderCell.filter(function (item) {
        return item.matcher === currentMatcher;
      })[0];
      var originalAreaIndex = Math.max(currentSelectionArea === null || currentSelectionArea === void 0 ? void 0 : currentSelectionArea.point1[type], currentSelectionArea === null || currentSelectionArea === void 0 ? void 0 : currentSelectionArea.point2[type], activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates[type]);
      var newIndexValue = type === 'column' ? columnValue : rowValue;
      var newPoint = {
        row: originalAreaIndex < newIndexValue ? rows.length - 1 : 0,
        column: columnValue
      };
      var selectionAreasClone = (0, _deepCloneObject.deepCloneObject)(prev);
      var indexOfCurrentArea = selectionAreasClone.findIndex(function (item) {
        return item.matcher === currentMatcher;
      });
      var newIndexList = getSelectedItemIndexList({
        indexList: ((_selectionAreasClone$ = selectionAreasClone[indexOfCurrentArea]) === null || _selectionAreasClone$ === void 0 ? void 0 : (_selectionAreasClone$2 = _selectionAreasClone$.header) === null || _selectionAreasClone$2 === void 0 ? void 0 : _selectionAreasClone$2.selectedIndexList) || [type === 'column' ? columnValue : rowValue],
        newIndex: newIndexValue,
        activeCellIndex: activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates[type]
      });
      var setPoint1 = function setPoint1(value) {
        return value < newIndexValue ? {
          row: type === 'column' ? 0 : Math.min.apply(Math, (0, _toConsumableArray2.default)(newIndexList)),
          column: type === 'column' ? Math.min.apply(Math, (0, _toConsumableArray2.default)(newIndexList)) : 0
        } : newPoint;
      };
      var setPoint2 = function setPoint2(value) {
        return value < newIndexValue ? newPoint : {
          row: type === 'column' ? rows.length - 1 : Math.max.apply(Math, (0, _toConsumableArray2.default)(newIndexList)),
          column: type === 'column' ? Math.max.apply(Math, (0, _toConsumableArray2.default)(newIndexList)) : columns.length - 1
        };
      };
      // If there is no active cell set and shift is clicked on a header cell
      if (!activeCellCoordinates || typeof activeCellCoordinates === 'undefined') {
        // Need to set positioning of active cell because it doesn't exist yet
        setCurrentMatcher(tempMatcher);
        var firstSelectionArea = {
          point1: setPoint1(type === 'column' ? columnValue : rowValue),
          point2: setPoint2(type === 'column' ? columnValue : rowValue),
          areaCreated: false,
          matcher: tempMatcher,
          header: {
            type: type,
            selectedIndexList: [type === 'column' ? columnValue : rowValue]
          }
        };
        setActiveCellCoordinates({
          row: type === 'column' ? 0 : rowValue,
          column: type === 'column' ? columnValue : 0
        });
        return [firstSelectionArea];
      }
      selectionAreasClone[indexOfCurrentArea].point1 = setPoint1(activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates[type]);
      selectionAreasClone[indexOfCurrentArea].point2 = setPoint2(activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates[type]);
      selectionAreasClone[indexOfCurrentArea].areaCreated = false;
      selectionAreasClone[indexOfCurrentArea].header.selectedIndexList = newIndexList;
      return selectionAreasClone;
    }
    return [newSelectionArea];
  });
};
exports.handleHeaderCellSelection = handleHeaderCellSelection;