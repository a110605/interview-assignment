"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var React = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _icons = require("@carbon/react/icons");
var _reactDnd = require("react-dnd");
var _classnames = _interopRequireDefault(require("classnames"));
var _settings = require("../../../settings");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// @flow
/*
 * Licensed Materials - Property of IBM
 * 5724-Q36
 * (c) Copyright IBM Corp. 2021
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

var useEffect = React.useEffect,
  useRef = React.useRef,
  useState = React.useState;
var blockClass = "".concat(_settings.pkg.prefix, "--datagrid");
var DRAG_TYPE = "".concat(blockClass, "__shared-ui-draggable-element");
var DraggableElement = function DraggableElement(_ref) {
  var _cx;
  var id = _ref.id,
    index = _ref.index,
    listData = _ref.listData,
    children = _ref.children,
    type = _ref.type,
    disabled = _ref.disabled,
    ariaLabel = _ref.ariaLabel,
    onGrab = _ref.onGrab,
    onArrowKeyDown = _ref.onArrowKeyDown,
    isFocused = _ref.isFocused,
    isSticky = _ref.isSticky,
    moveElement = _ref.moveElement,
    selected = _ref.selected,
    _ref$positionLabel = _ref.positionLabel,
    positionLabel = _ref$positionLabel === void 0 ? 'Current position {index} of {total}' : _ref$positionLabel,
    _ref$grabbedLabel = _ref.grabbedLabel,
    grabbedLabel = _ref$grabbedLabel === void 0 ? '{itemName} grabbed.' : _ref$grabbedLabel,
    _ref$droppedLabel = _ref.droppedLabel,
    droppedLabel = _ref$droppedLabel === void 0 ? '{itemName} dropped.' : _ref$droppedLabel;
  var ref = useRef();
  var _useDrop = (0, _reactDnd.useDrop)({
      accept: DRAG_TYPE + type,
      collect: function collect(monitor) {
        return {
          isOver: !!monitor.isOver()
        };
      },
      drop: function drop(item) {
        moveElement(item.index, index);
      },
      canDrop: function canDrop() {
        return !disabled;
      },
      hover: function hover(item) {
        var dragIndex = item.index;
        var hoverIndex = index;
        // Don't replace items with themselves
        if (dragIndex === hoverIndex || disabled) {
          return;
        }
        moveElement(dragIndex, hoverIndex);
        // Time to actually perform the action
        // Note: we're mutating the monitor item here!
        // Generally it's better to avoid mutations,
        // but it's good here for the sake of performance
        // to avoid expensive index searches.
        // eslint-disable-next-line no-param-reassign
        item.index = hoverIndex;
      }
    }),
    _useDrop2 = (0, _slicedToArray2.default)(_useDrop, 2),
    isOver = _useDrop2[0].isOver,
    drop = _useDrop2[1];
  var _useDrag = (0, _reactDnd.useDrag)({
      type: DRAG_TYPE + type,
      item: {
        id: id,
        index: index
      },
      canDrag: function canDrag() {
        return !disabled;
      },
      collect: function collect(monitor) {
        return {
          isDragging: monitor.isDragging()
        };
      }
    }),
    _useDrag2 = (0, _slicedToArray2.default)(_useDrag, 3),
    isDragging = _useDrag2[0].isDragging,
    drag = _useDrag2[1],
    preview = _useDrag2[2];
  useEffect(function () {
    if (isFocused && ref && ref.current) {
      ref.current.focus();
    }
  }, [isFocused]);
  var _useState = useState(false),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    isGrabbed = _useState2[0],
    setIsGrabbed = _useState2[1];
  var _useState3 = useState(isFocused),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    isFocusedOnItem = _useState4[0],
    setIsFocusedOnItem = _useState4[1];
  drop(ref);
  var content = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    className: (0, _classnames.default)({
      disabled: disabled
    }, "".concat(blockClass, "__draggable-handleStyle"))
  }, isSticky ? /*#__PURE__*/React.createElement(_icons.Locked, {
    size: 16
  }) : /*#__PURE__*/React.createElement(_icons.Draggable, {
    size: 16
  })), children);
  return /*#__PURE__*/React.createElement("li", {
    className: (0, _classnames.default)((_cx = {}, (0, _defineProperty2.default)(_cx, "".concat(blockClass, "__draggable-handleHolder-isOver"), isOver && !disabled), (0, _defineProperty2.default)(_cx, "".concat(blockClass, "__draggable-handleHolder-grabbed"), isGrabbed), (0, _defineProperty2.default)(_cx, "".concat(blockClass, "__draggable-handleHolder-selected"), selected), (0, _defineProperty2.default)(_cx, "".concat(blockClass, "__draggable-handleHolder--sticky"), isSticky), (0, _defineProperty2.default)(_cx, "".concat(blockClass, "__draggable-handleHolder"), !selected), _cx)),
    ref: ref,
    "aria-selected": isFocused,
    role: "option",
    tabIndex: isFocused ? 0 : -1,
    onKeyPress: function onKeyPress(e) {
      if (e.key === ' ' && e.target === e.currentTarget && !disabled) {
        var positionText = positionLabel.replace('{index}', index + 1).replace('{total}', listData.length);
        var grabAriaText = (isGrabbed ? droppedLabel : grabbedLabel).replace('{itemName}', ariaLabel);
        onGrab(grabAriaText + positionText);
        setIsGrabbed(!isGrabbed);
        e.preventDefault();
      }
    },
    onKeyDown: function onKeyDown(e) {
      if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
        onArrowKeyDown(e, isGrabbed, index);
      }
    },
    onBlur: function onBlur(e) {
      // handle when focus move to inner elements
      setIsFocusedOnItem(e.currentTarget === e.target);
    },
    onFocus: function onFocus(e) {
      // handle when focus move to li element
      setIsFocusedOnItem(e.currentTarget === e.target);
    }
  }, /*#__PURE__*/React.createElement("span", {
    className: "".concat(blockClass, "__shared-ui--assistive-text")
  }, ariaLabel), isDragging && !isOver ? /*#__PURE__*/React.createElement("div", {
    ref: preview,
    className: "".concat(blockClass, "__draggable-handleHolder-droppable ").concat(blockClass, "__draggable-handleHolder-droppable--origin")
  }, content) : /*#__PURE__*/React.createElement("div", {
    ref: drag,
    "aria-hidden": isFocused && isFocusedOnItem // if focus on li, hide the children from aria
    ,
    className: (0, _classnames.default)((0, _defineProperty2.default)({}, "".concat(blockClass, "__draggable-handleStyle"), !disabled), ["".concat(blockClass, "__draggable-handleHolder-droppable")])
  }, (!isOver || disabled) && content));
};
DraggableElement.propTypes = {
  ariaLabel: _propTypes.default.string.isRequired,
  children: _propTypes.default.element.isRequired,
  disabled: _propTypes.default.bool,
  droppedLabel: _propTypes.default.string,
  grabbedLabel: _propTypes.default.string,
  id: _propTypes.default.string.isRequired,
  index: _propTypes.default.number.isRequired,
  isFocused: _propTypes.default.bool.isRequired,
  isSticky: _propTypes.default.bool,
  listData: _propTypes.default.array.isRequired,
  moveElement: _propTypes.default.func.isRequired,
  onArrowKeyDown: _propTypes.default.func.isRequired,
  onGrab: _propTypes.default.func.isRequired,
  positionLabel: _propTypes.default.string,
  selected: _propTypes.default.bool,
  type: _propTypes.default.string.isRequired
};
var _default = DraggableElement;
exports.default = _default;