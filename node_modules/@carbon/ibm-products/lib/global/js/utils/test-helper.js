"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scssCompile = exports.scssCheck = exports.required = exports.mockHTMLElement = exports.invalid = exports.expectWarnAsync = exports.expectWarn = exports.expectMultipleWarn = exports.expectMultipleError = exports.expectLogging = exports.expectError = exports.deprecatedUsage = exports.deprecated = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
//
// Copyright IBM Corp. 2021, 2021
//
// This source code is licensed under the Apache-2.0 license found in the
// LICENSE file in the root directory of this source tree.
//

var _require = require('child_process'),
  execFileSync = _require.execFileSync;
var _require2 = require('path'),
  resolve = _require2.resolve;
var r = function r(file) {
  return resolve(__dirname, file);
};
var loadPath1 = r('../../../../node_modules');
var loadPath2 = r('../../../../../../node_modules');

/**
 * Check that an SCSS file compiles correctly. This function does not return
 * a value, but if the SCSS file does not compile it will throw an Error
 * containing details of the compilation failure.
 * @param {string} file fully qualified file name of the SCSS file to check.
 */
var scssCheck = function scssCheck(file) {
  // We use the sass cli because this is currently much faster than using
  // the API owing to the overhead of @import resolution through the API.
  // When the sass API is revised it may be feasible to switch back to
  // using the API for SCSS compilation and checking.
  execFileSync('sass', ['--style=expanded', '--no-source-map', '--load-path', loadPath1, '--load-path', loadPath2, file], {
    stdio: ['ignore', 'ignore', 'pipe']
  });
};

/**
 * Compile an SCSS file, and return the compiled CSS as a String. If the SCSS
 * file does not compile this function will throw an Error containing details
 * of the compilation failure.
 * @param {string} file fully qualified file name of the SCSS file to compile.
 */
exports.scssCheck = scssCheck;
var scssCompile = function scssCompile(file) {
  var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return (
    // We use the sass cli because this is currently much faster than using
    // the API owing to the overhead of @import resolution through the API.
    // When the sass API is revised it may be feasible to switch back to
    // using the API for SCSS compilation and checking.
    execFileSync('sass', [compressed ? '--style=compressed' : '--style=expanded', '--no-source-map', '--load-path', loadPath1, '--load-path', loadPath2, file], {
      stdio: ['ignore', 'pipe', 'pipe'],
      maxBuffer: 1024 * 1024 * 1.5
    }).toString()
  );
};

/**
 * A helper function to mock properties of the HTML element prototype.
 * @param {*} options An object containing one or more properties, being the
 * names of properties to add/replace in the HTML element prototype along with
 * a property descriptor to apply. The property descriptor may contain a value
 * field, and optionally a writable flag, or it may contain a get and/or a set
 * method. Other property descriptor fields may also be included, but each
 * mocked property will always be made configurable (in order to enable the
 * mock to be restored later).
 * @returns An object containing a mockRestore function which will return all
 * replaced properties to their original states and remove all added properties.
 * This function should be called after tests in order not to pollute other
 * tests with the installed mocks.
 */
exports.scssCompile = scssCompile;
var hep = HTMLElement.prototype;
var mockHTMLElement = function mockHTMLElement(options) {
  var originals = {};
  for (var option in options) {
    originals[option] = Object.getOwnPropertyDescriptor(hep, option);
    Object.defineProperty(hep, option,
    // Ensure we'll be able to restore or delete the property later
    Object.assign({}, options[option], {
      configurable: true
    }));
  }
  return {
    mockRestore: function mockRestore() {
      for (var _option in options) {
        if (originals[_option]) {
          Object.defineProperty(hep, _option, originals[_option]);
        } else {
          delete hep[_option];
        }
      }
    }
  };
};

// a utility function used by expectWarn/Error to convert an argument
// match element to an expect matcher
exports.mockHTMLElement = mockHTMLElement;
var makeMatcher = function makeMatcher(arg) {
  return typeof arg === 'string' ? expect.stringContaining(arg) : arg instanceof RegExp ? expect.stringMatching(arg) : arg;
};

// a utility function used by expectWarn/Error to convert a single argument
// match or an array of argument matches to an array of expect matchers
var makeMatcherArray = function makeMatcherArray(args) {
  return Array.isArray(args) ? args.map(function (arg) {
    return makeMatcher(arg);
  }) : [makeMatcher(args)];
};

/**
 * A helper function to enable a test to expect a single call to
 * console.warn, for example when intentionally using a deprecated prop
 * or supplying invalid parameters for the purposes of the test.
 * @param {string|regex|function|[]} message the expected parameters for the call to
 * console.warn, which must be called exactly once. A single string or regex or an
 * expect matcher can be used to match a single-argument call to console.warn (most common),
 * while an array of strings and/or regex and/or expect matchers can be used to match a
 * multiple-argument call. Strings can be full or substring matches to the corresponding
 * argument.
 * @param {Function} test the test function to call, during which the call to
 * console.warn will be expected.
 */
var expectWarn = function expectWarn(message, test) {
  var _expect;
  var warn = jest.spyOn(console, 'warn').mockImplementation(jest.fn());
  var result = test();
  expect(warn).toBeCalledTimes(1);
  (_expect = expect(warn)).toHaveBeenCalledWith.apply(_expect, (0, _toConsumableArray2.default)(makeMatcherArray(message)));
  warn.mockRestore();
  return result;
};

/**
 * An async version of expectWarn which awaits the test function and expects the call
 * to console.warn to have been made.
 */
exports.expectWarn = expectWarn;
var expectWarnAsync = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(message, test) {
    var _expect2;
    var warn;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          warn = jest.spyOn(console, 'warn').mockImplementation(jest.fn());
          _context.next = 3;
          return test();
        case 3:
          expect(warn).toBeCalledTimes(1);
          (_expect2 = expect(warn)).toHaveBeenCalledWith.apply(_expect2, (0, _toConsumableArray2.default)(makeMatcherArray(message)));
          warn.mockRestore();
        case 6:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function expectWarnAsync(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

/**
 * A helper function to enable a test to expect multiple calls to
 * console.warn, for example when intentionally using a deprecated prop
 * or supplying invalid parameters for the purposes of the test.
 * @param {[]} messages the expected parameters for successive calls to console.warn,
 * which must be called exactly as many times as there are elements in the array.
 * Each element of the array can either be a string or a regex or an expect matcher,
 * all of which can be used to match a single-argument call to console.warn (most common),
 * or can be an array of strings and/or regex and/or expect matchers, to match a
 * multiple-argument call. Strings can be full or substring matches to the corresponding
 * argument.
 * @param {Function} test the test function to call, during which the calls to
 * console.warn will be expected.
 */
exports.expectWarnAsync = expectWarnAsync;
var expectMultipleWarn = function expectMultipleWarn(messages, test) {
  var warn = jest.spyOn(console, 'warn').mockImplementation(jest.fn());
  var result = test();
  expect(warn).toBeCalledTimes(messages.length);
  messages.forEach(function (args, index) {
    var _expect3;
    return (_expect3 = expect(warn)).toHaveBeenNthCalledWith.apply(_expect3, [index + 1].concat((0, _toConsumableArray2.default)(makeMatcherArray(args))));
  });
  warn.mockRestore();
  return result;
};
exports.expectMultipleWarn = expectMultipleWarn;
var checkLogging = function checkLogging(mock, message) {
  if (message) {
    var _expect4;
    expect(mock).toBeCalled();
    (_expect4 = expect(mock)).toHaveBeenCalledWith.apply(_expect4, (0, _toConsumableArray2.default)(makeMatcherArray(message)));
  }
};

/**
 * A helper function to enable a test to expect a single call to
 * console.error, for example when intentionally omitting a required prop
 * or supplying an invalid prop type or value for the purposes of the test.
 * @param {errors: {string|regex|function|[]}, warnings: {string|regex|function|[]}} messages the expected parameters for the call to
 * console.error or console.warn, which must be called exactly once. A single string or regex or an
 * expect matcher can be used to match a single-argument call to console.error (most common),
 * while an array of strings and/or regex and/or expect matchers can be used to match a
 * multiple-argument call. Strings can be full or substring matches to the corresponding
 * argument.
 * @param {Function} test the test function to call, during which the call to
 * console.error will be expected.
 */
var expectLogging = function expectLogging(_ref2, test) {
  var errors = _ref2.errors,
    warnings = _ref2.warnings;
  var error = jest.spyOn(console, 'error').mockImplementation(jest.fn());
  var warn = jest.spyOn(console, 'warn').mockImplementation(jest.fn());
  var result = test();
  checkLogging(error, errors);
  checkLogging(warn, warnings);
  error.mockRestore();
  warn.mockRestore();
  return result;
};

/**
 * A helper function to enable a test to expect a single call to
 * console.error, for example when intentionally omitting a required prop
 * or supplying an invalid prop type or value for the purposes of the test.
 * @param {string|regex|function|[]} message the expected parameters for the call to
 * console.error, which must be called exactly once. A single string or regex or an
 * expect matcher can be used to match a single-argument call to console.error (most common),
 * while an array of strings and/or regex and/or expect matchers can be used to match a
 * multiple-argument call. Strings can be full or substring matches to the corresponding
 * argument.
 * @param {Function} test the test function to call, during which the call to
 * console.error will be expected.
 */
exports.expectLogging = expectLogging;
var expectError = function expectError(message, test) {
  var error = jest.spyOn(console, 'error').mockImplementation(jest.fn());
  var result = test();
  checkLogging(error, message);
  error.mockRestore();
  return result;
};

/**
 * A helper function to enable a test to expect multiple calls to
 * console.warn, for example when intentionally using a deprecated prop
 * or supplying invalid parameters for the purposes of the test.
 * @param {[]} messages the expected parameters for successive calls to console.error,
 * which must be called exactly as many times as there are elements in the array.
 * Each element of the array can either be a string or a regex or an expect matcher,
 * all of which can be used to match a single-argument call to console.error (most common),
 * or can be an array of strings and/or regex and/or expect matchers, to match a
 * multiple-argument call. Strings can be full or substring matches to the corresponding
 * argument.
 * @param {Function} test the test function to call, during which the calls to
 * console.error will be expected.
 */
exports.expectError = expectError;
var expectMultipleError = function expectMultipleError(messages, test) {
  var error = jest.spyOn(console, 'error').mockImplementation(jest.fn());
  var result = test();
  expect(error).toBeCalledTimes(messages.length);
  messages.forEach(function (args, index) {
    var _expect5;
    return (_expect5 = expect(error)).toHaveBeenNthCalledWith.apply(_expect5, [index + 1].concat((0, _toConsumableArray2.default)(makeMatcherArray(args))));
  });
  error.mockRestore();
  return result;
};

/**
 * Return an expect matcher for a prop deprecation, suitable to pass to expectWarn
 * or expectMultipleWarn.
 * @param {string} propName the prop name that is deprecated, or a matching regex
 * @param {string} componentName the component name on which the prop is defined, or a matching regex
 */
exports.expectMultipleError = expectMultipleError;
var deprecated = function deprecated(propName, componentName) {
  var additionalInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  return expect.stringMatching(new RegExp("^The prop `".concat(propName, "` of `").concat(componentName, "` has been deprecated and will soon be removed. ").concat(additionalInfo)));
};

/**
 * Return an expect matcher for a prop usage deprecation, suitable to pass to expectWarn
 * or expectMultipleWarn.
 * @param {string} propName the prop name whose usage has changed
 * @param {string} componentName the component name on which the prop is defined
 */
exports.deprecated = deprecated;
var deprecatedUsage = function deprecatedUsage(propName, componentName) {
  var additionalInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  return expect.stringMatching(new RegExp("^The usage of the prop `".concat(propName, "` of `").concat(componentName, "` has been changed and support for the old usage will soon be removed. ").concat(additionalInfo)));
};

/**
 * Return an expect matcher for a missing required prop, suitable to pass to expectError
 * or expectMultipleError.
 * @param {string} propName the prop name that is required, or a matching regex
 * @param {string} componentName the component name on which the prop is defined, or a matching regex
 */
exports.deprecatedUsage = deprecatedUsage;
var required = function required(propName, componentName) {
  return expect.stringMatching(new RegExp("^Warning: Failed prop type: The prop `".concat(propName, "` is marked as required in `").concat(componentName, "`, but its value is `(.*)`.")));
};

/**
 * Return an expect matcher for an invalid prop, suitable to pass to expectError
 * or expectMultipleError.
 * @param {string} propName the prop name that is invalid, or a matching regex
 * @param {string} componentName the component name on which the prop is defined, or a matching regex
 * @param {string} suppliedType the type that is being supplied, or a matching regex
 * @param {string} expectedType the type that is expected, or a matching regex
 */
exports.required = required;
var invalid = function invalid(propName, componentName, suppliedType, expectedType) {
  return expect.stringMatching(new RegExp("^Warning: Failed prop type: Invalid prop `".concat(propName, "` of type `").concat(suppliedType, "` supplied to `").concat(componentName, "`, expected `").concat(expectedType, "`.")));
};
exports.invalid = invalid;