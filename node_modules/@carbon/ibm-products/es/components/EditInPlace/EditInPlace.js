import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _typeof from "@babel/runtime/helpers/typeof";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["cancelLabel", "editAlwaysVisible", "editLabel", "id", "inheritTypography", "invalid", "invalidLabel", "invalidText", "labelText", "onCancel", "onChange", "onSave", "saveLabel", "size", "tooltipAlignment", "value"];
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * Copyright IBM Corp. 2022, 2022
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

import React, { useState, useEffect, forwardRef, useRef } from 'react';
import { IconButton } from '@carbon/react';
import cx from 'classnames';
import PropTypes from 'prop-types';
import { Edit, Checkmark, Close,
// EditOff,
WarningFilled } from '@carbon/react/icons';
import { pkg, carbon } from '../../settings';
import { getDevtoolsProps } from '../../global/js/utils/devtools';
var componentName = 'EditInPlace';
var blockClass = "".concat(pkg.prefix, "--edit-in-place");
var defaults = {
  tooltipAlignment: 'top',
  size: 'sm'
};
export var EditInPlace = /*#__PURE__*/forwardRef(function (_ref, ref) {
  var _cx;
  var cancelLabel = _ref.cancelLabel,
    editAlwaysVisible = _ref.editAlwaysVisible,
    editLabel = _ref.editLabel,
    id = _ref.id,
    inheritTypography = _ref.inheritTypography,
    invalid = _ref.invalid,
    deprecated_invalidLabel = _ref.invalidLabel,
    invalidText = _ref.invalidText,
    labelText = _ref.labelText,
    onCancel = _ref.onCancel,
    onChange = _ref.onChange,
    onSave = _ref.onSave,
    saveLabel = _ref.saveLabel,
    _ref$size = _ref.size,
    size = _ref$size === void 0 ? defaults.size : _ref$size,
    tooltipAlignment = _ref.tooltipAlignment,
    value = _ref.value,
    rest = _objectWithoutProperties(_ref, _excluded);
  var _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    focused = _useState2[0],
    setFocused = _useState2[1];
  var _useState3 = useState(''),
    _useState4 = _slicedToArray(_useState3, 2),
    initialValue = _useState4[0],
    setInitialValue = _useState4[1];
  var _useState5 = useState(false),
    _useState6 = _slicedToArray(_useState5, 2),
    dirtyInput = _useState6[0],
    setDirtyInput = _useState6[1];
  var inputRef = useRef(null);
  var canSave = value !== initialValue && !invalid;
  var escaping = useRef(false);
  var tipAlignIsObject = _typeof(tooltipAlignment) === 'object';
  var tipAlignments = ['edit', 'save', 'cancel'].reduce(function (acc, tips) {
    var _ref2;
    acc[tips] = (_ref2 = tipAlignIsObject ? tooltipAlignment[tips] : tooltipAlignment) !== null && _ref2 !== void 0 ? _ref2 : defaults.tooltipAlignment;
    return acc;
  }, {});
  useEffect(function () {
    if (!initialValue && !dirtyInput) {
      setInitialValue(value);
    }
  }, [initialValue, dirtyInput, value]);
  var isTargetingChild = function isTargetingChild(_ref3) {
    var currentTarget = _ref3.currentTarget,
      relatedTarget = _ref3.relatedTarget;
    return currentTarget.contains(relatedTarget);
  };
  var onChangeHandler = function onChangeHandler(_ref4) {
    var target = _ref4.target;
    if (!dirtyInput) {
      setDirtyInput(true);
    }
    onChange(target.value);
  };
  var onFocusHandler = function onFocusHandler(e) {
    // if (readOnly) {
    //   return;
    // }

    if (!isTargetingChild(e)) {
      inputRef.current.focus();
      setFocused(true);
    }
  };
  var onSaveHandler = function onSaveHandler() {
    setInitialValue(value);
    setFocused(false);
    setDirtyInput(false);
    onSave();
  };
  var onCancelHandler = function onCancelHandler() {
    setFocused(false);
    setDirtyInput(false);
    onCancel(initialValue);
  };
  var onBlurHandler = function onBlurHandler(e) {
    // if (readOnly || escaping.current) {
    if (escaping.current) {
      return;
    }
    if (!isTargetingChild(e)) {
      if (canSave) {
        onSaveHandler();
      } else {
        onCancelHandler();
      }
    }
  };
  var returnHandler = function returnHandler() {
    if (canSave) {
      onSaveHandler();
    }
  };
  var escapeHandler = function escapeHandler() {
    onCancelHandler();
  };
  var onKeyHandler = function onKeyHandler(e) {
    // to prevent blur handler from being called twice add additional state to check if escape is being used
    escaping.current = true;
    switch (e.key) {
      case 'Escape':
        inputRef.current.blur();
        escapeHandler();
        break;
      case 'Enter':
        inputRef.current.blur();
        returnHandler();
        break;
      default:
        break;
    }
    escaping.current = false;
  };
  return /*#__PURE__*/React.createElement("div", _extends({}, rest, {
    ref: ref
  }, getDevtoolsProps(componentName)), /*#__PURE__*/React.createElement("div", {
    className: cx(blockClass, "".concat(blockClass, "--").concat(size), (_cx = {}, _defineProperty(_cx, "".concat(blockClass, "--focused"), focused), _defineProperty(_cx, "".concat(blockClass, "--invalid"), invalid), _defineProperty(_cx, "".concat(blockClass, "--inherit-type"), inheritTypography), _defineProperty(_cx, "".concat(blockClass, "--overflows"), inputRef.current && inputRef.current.scrollWidth > inputRef.current.offsetWidth), _cx)),
    onFocus: onFocusHandler,
    onBlur: onBlurHandler
  }, /*#__PURE__*/React.createElement("label", {
    className: "".concat(blockClass, "__text-input-label"),
    htmlFor: id
  }, labelText), /*#__PURE__*/React.createElement("input", {
    id: id,
    className: cx("".concat(blockClass, "__text-input"), "".concat(carbon.prefix, "--text-input"), "".concat(carbon.prefix, "--text-input--").concat(size)),
    type: "text",
    value: value,
    onChange: onChangeHandler,
    ref: inputRef
    // readOnly={readOnly}
    ,
    onKeyDown: onKeyHandler
  }), /*#__PURE__*/React.createElement("div", {
    className: "".concat(blockClass, "__ellipsis"),
    "aria-hidden": !focused
  }, "\u2026"), /*#__PURE__*/React.createElement("div", {
    className: "".concat(blockClass, "__toolbar")
  }, invalid && /*#__PURE__*/React.createElement(WarningFilled, {
    size: 16,
    className: "".concat(blockClass, "__warning-icon")
  }), focused ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(IconButton, {
    align: tipAlignments.cancel,
    size: size,
    label: cancelLabel,
    onClick: onCancelHandler,
    kind: "ghost",
    tabIndex: 0,
    key: "cancel",
    className: "".concat(blockClass, "__btn ").concat(blockClass, "__btn-cancel")
  }, /*#__PURE__*/React.createElement(Close, {
    size: 16
  })), /*#__PURE__*/React.createElement(IconButton, {
    align: tipAlignments.save,
    size: size,
    label: saveLabel,
    onClick: onSaveHandler,
    kind: "ghost",
    tabIndex: 0,
    key: "save",
    className: "".concat(blockClass, "__btn ").concat(blockClass, "__btn-save"),
    disabled: !canSave
  }, /*#__PURE__*/React.createElement(Checkmark, {
    size: 16
  }))) : /*#__PURE__*/React.createElement(IconButton, {
    align: tipAlignments.edit,
    className: cx("".concat(blockClass, "__btn"), "".concat(blockClass, "__btn-edit"), _defineProperty({}, "".concat(blockClass, "__btn-edit--always-visible"), editAlwaysVisible)),
    size: size,
    label: editLabel,
    onClick: onFocusHandler,
    kind: "ghost",
    tabIndex: 0,
    key: "edit"
  }, /*#__PURE__*/React.createElement(Edit, {
    size: 16
  })))), invalid && /*#__PURE__*/React.createElement("p", {
    className: "".concat(blockClass, "__warning-text")
  }, invalidText !== null && invalidText !== void 0 ? invalidText : deprecated_invalidLabel));
});
EditInPlace = pkg.checkComponentEnabled(EditInPlace, componentName);
EditInPlace.displayName = componentName;
export var deprecatedProps = {
  /**
   * **Deprecated**
   * invalidLabel was misnamed, using invalidText to match Carbon
   */
  invalidText: PropTypes.string
};
var alignPropType = PropTypes.oneOf(['top', 'top-left', 'top-right', 'bottom', 'bottom-left', 'bottom-right', 'left', 'right']);
EditInPlace.propTypes = _objectSpread({
  /**
   * label for cancel button
   */
  cancelLabel: PropTypes.string.isRequired,
  /**
   * By default the edit icon is shown on hover only.
   */
  editAlwaysVisible: PropTypes.bool,
  /**
  /**
   * label for edit button
   */
  editLabel: PropTypes.string.isRequired,
  /**
   * Specify a custom id for the input
   */
  id: PropTypes.string.isRequired,
  /**
   * inheritTypography - causes the text entry field to inherit typography settings
   * assigned to the container. This is useful when editing titles for instance.
   *
   * NOTE: The size property limits the vertical size of the input element.
   * Inherited font's should be selected to fit within the size selected.
   */
  inheritTypography: PropTypes.bool,
  /**
   * determines if the input is invalid
   */
  invalid: PropTypes.bool,
  /**
   * text that is displayed if the input is invalid
   */
  invalidText: PropTypes.string,
  /**
   * Provide the text that will be read by a screen reader when visiting this control
   */
  labelText: PropTypes.string.isRequired,
  /**
   * handler that is called when the cancel button is pressed or when the user removes focus from the input and there is no new value
   */
  onCancel: PropTypes.func.isRequired,
  /**
   * handler that is called when the input is updated
   */
  onChange: PropTypes.func.isRequired,
  /**
   * handler that is called when the save button is pressed or when the user removes focus from the input if it has a new value
   */
  onSave: PropTypes.func.isRequired,
  /**
   * determines if the input is in readOnly mode
   */
  // readOnly: PropTypes.bool,
  /**
   * label for the edit button that displays when in read only mode
   */
  // readOnlyLabel: PropTypes.string,
  /**
   * label for save button
   */
  saveLabel: PropTypes.string.isRequired,
  /**
   * vertical size of control
   */
  size: PropTypes.oneOf(['sm', 'md', 'lg']),
  /**
   * tooltipAlignment from the standard tooltip. Default center.
   *
   * Can be passed either as one of tooltip options or as an object specifying cancel, edit and save separately
   */
  tooltipAlignment: PropTypes.oneOfType([alignPropType, PropTypes.shape({
    cancel: alignPropType,
    edit: alignPropType,
    save: alignPropType
  })]),
  /**
   * current value of the input
   */
  value: PropTypes.string.isRequired
}, deprecatedProps);