import _extends from "@babel/runtime/helpers/extends";
import _typeof from "@babel/runtime/helpers/typeof";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["cellSize", "className", "columns", "data", "defaultEmptyRowCount", "onDataUpdate", "id", "onActiveCellChange", "onSelectionAreaChange", "selectAllAriaLabel", "spreadsheetAriaLabel", "theme", "totalVisibleColumns"];
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * Copyright IBM Corp. 2022, 2022
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

// Import portions of React that are needed.
import React, { useMemo, useRef, useState, useCallback, useEffect } from 'react';
import { useBlockLayout, useTable, useColumnOrder } from 'react-table';

// Other standard imports.
import PropTypes from 'prop-types';
import cx from 'classnames';
import { pkg } from '../../settings';
import { DataSpreadsheetBody } from './DataSpreadsheetBody';
import { DataSpreadsheetHeader } from './DataSpreadsheetHeader';
import { getDevtoolsProps } from '../../global/js/utils/devtools';
import { getScrollbarWidth } from '../../global/js/utils/getScrollbarWidth';
import { useActiveElement, usePreviousValue } from '../../global/js/hooks';
import uuidv4 from '../../global/js/utils/uuidv4';
import { deepCloneObject } from '../../global/js/utils/deepCloneObject';
import { useResetSpreadsheetFocus, useSpreadsheetOutsideClick, useMoveActiveCell, useMultipleKeyTracking, useSpreadsheetEdit } from './hooks';
import { createActiveCellFn } from './utils/createActiveCellFn';
import { getCellSize } from './utils/getCellSize';
import { handleMultipleKeys, includesResourceKey, includesShift } from './utils/handleMultipleKeys';
import { handleHeaderCellSelection } from './utils/handleHeaderCellSelection';
import { removeCellSelections } from './utils/removeCellSelections';
import { selectAllCells } from './utils/selectAllCells';
import { handleEditSubmit } from './utils/handleEditSubmit';
import { handleActiveCellInSelectionEnter } from './utils/handleActiveCellInSelectionEnter';
import { handleActiveCellInSelectionTab } from './utils/handleActiveCellInSelectionTab';
import { handleCellDeletion } from './utils/handleCellDeletion';
// cspell:words rowcount colcount

// The block part of our conventional BEM class names (blockClass__E--M).
var blockClass = "".concat(pkg.prefix, "--data-spreadsheet");
var componentName = 'DataSpreadsheet';

// Default values for props
var defaults = {
  cellSize: 'sm',
  columns: Object.freeze([]),
  data: Object.freeze([]),
  defaultEmptyRowCount: 16,
  onDataUpdate: Object.freeze(function () {}),
  onActiveCellChange: Object.freeze(function () {}),
  onSelectionAreaChange: Object.freeze(function () {}),
  theme: 'light'
};

/**
 * DataSpreadsheet: used to organize and display large amounts of structured data, separated by columns and rows in a grid-like format.
 */
export var DataSpreadsheet = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var _cx;
  var _ref$cellSize = _ref.cellSize,
    cellSize = _ref$cellSize === void 0 ? defaults.cellSize : _ref$cellSize,
    className = _ref.className,
    _ref$columns = _ref.columns,
    columns = _ref$columns === void 0 ? defaults.columns : _ref$columns,
    _ref$data = _ref.data,
    data = _ref$data === void 0 ? defaults.data : _ref$data,
    _ref$defaultEmptyRowC = _ref.defaultEmptyRowCount,
    defaultEmptyRowCount = _ref$defaultEmptyRowC === void 0 ? defaults.defaultEmptyRowCount : _ref$defaultEmptyRowC,
    _ref$onDataUpdate = _ref.onDataUpdate,
    onDataUpdate = _ref$onDataUpdate === void 0 ? defaults.onDataUpdate : _ref$onDataUpdate,
    id = _ref.id,
    _ref$onActiveCellChan = _ref.onActiveCellChange,
    onActiveCellChange = _ref$onActiveCellChan === void 0 ? defaults.onActiveCellChange : _ref$onActiveCellChan,
    _ref$onSelectionAreaC = _ref.onSelectionAreaChange,
    onSelectionAreaChange = _ref$onSelectionAreaC === void 0 ? defaults.onSelectionAreaChange : _ref$onSelectionAreaC,
    selectAllAriaLabel = _ref.selectAllAriaLabel,
    spreadsheetAriaLabel = _ref.spreadsheetAriaLabel,
    theme = _ref.theme,
    totalVisibleColumns = _ref.totalVisibleColumns,
    rest = _objectWithoutProperties(_ref, _excluded);
  var multiKeyTrackingRef = useRef();
  var localRef = useRef();
  var spreadsheetRef = ref || localRef;
  var focusedElement = useActiveElement();
  var _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    containerHasFocus = _useState2[0],
    setContainerHasFocus = _useState2[1];
  var _useState3 = useState(null),
    _useState4 = _slicedToArray(_useState3, 2),
    activeCellCoordinates = _useState4[0],
    setActiveCellCoordinates = _useState4[1];
  var _useState5 = useState([]),
    _useState6 = _slicedToArray(_useState5, 2),
    selectionAreas = _useState6[0],
    setSelectionAreas = _useState6[1];
  var _useState7 = useState([]),
    _useState8 = _slicedToArray(_useState7, 2),
    selectionAreaData = _useState8[0],
    setSelectionAreaData = _useState8[1];
  var _useState9 = useState(false),
    _useState10 = _slicedToArray(_useState9, 2),
    clickAndHoldActive = _useState10[0],
    setClickAndHoldActive = _useState10[1];
  var _useState11 = useState(''),
    _useState12 = _slicedToArray(_useState11, 2),
    currentMatcher = _useState12[0],
    setCurrentMatcher = _useState12[1];
  var _useState13 = useState(false),
    _useState14 = _slicedToArray(_useState13, 2),
    isEditing = _useState14[0],
    setIsEditing = _useState14[1];
  var _useState15 = useState(''),
    _useState16 = _slicedToArray(_useState15, 2),
    cellEditorValue = _useState16[0],
    setCellEditorValue = _useState16[1];
  var _useState17 = useState(false),
    _useState18 = _slicedToArray(_useState17, 2),
    headerCellHoldActive = _useState18[0],
    setHeaderCellHoldActive = _useState18[1];
  var _useState19 = useState(false),
    _useState20 = _slicedToArray(_useState19, 2),
    activeCellInsideSelectionArea = _useState20[0],
    setActiveCellInsideSelectionArea = _useState20[1];
  var previousState = usePreviousValue({
    activeCellCoordinates: activeCellCoordinates,
    isEditing: isEditing
  });
  var cellSizeValue = getCellSize(cellSize);
  var cellEditorRef = useRef();
  var _useState21 = useState(),
    _useState22 = _slicedToArray(_useState21, 2),
    activeCellContent = _useState22[0],
    setActiveCellContent = _useState22[1];
  var activeCellRef = useRef();
  var cellEditorRulerRef = useRef();
  var defaultColumn = useMemo(function () {
    return {
      width: 150,
      rowHeaderWidth: 64,
      rowHeight: cellSizeValue
    };
  }, [cellSizeValue]);
  var _useMultipleKeyTracki = useMultipleKeyTracking({
      ref: multiKeyTrackingRef,
      containerHasFocus: containerHasFocus,
      isEditing: isEditing
    }),
    keysPressedList = _useMultipleKeyTracki.keysPressedList,
    usingMac = _useMultipleKeyTracki.usingMac;
  var scrollBarSize = useMemo(function () {
    return getScrollbarWidth();
  }, []);
  var _useTable = useTable({
      columns: columns,
      data: data,
      defaultColumn: defaultColumn
    }, useBlockLayout, useColumnOrder),
    getTableProps = _useTable.getTableProps,
    getTableBodyProps = _useTable.getTableBodyProps,
    headerGroups = _useTable.headerGroups,
    rows = _useTable.rows,
    totalColumnsWidth = _useTable.totalColumnsWidth,
    prepareRow = _useTable.prepareRow,
    setColumnOrder = _useTable.setColumnOrder,
    visibleColumns = _useTable.visibleColumns;

  // Update the spreadsheet data after editing a cell
  var updateData = useCallback(function (rowIndex, columnId, newValue) {
    onDataUpdate(function (prev) {
      return prev.map(function (row, index) {
        if (index === rowIndex) {
          return _objectSpread(_objectSpread({}, prev[rowIndex]), {}, _defineProperty({}, columnId, cellEditorValue || newValue));
        }
        return row;
      });
    });
  }, [cellEditorValue, onDataUpdate]);

  // Removes the active cell element
  var removeActiveCell = useCallback(function () {
    var activeCellHighlight = spreadsheetRef.current.querySelector(".".concat(blockClass, "__active-cell--highlight"));
    activeCellHighlight.style.display = 'none';
  }, [spreadsheetRef]);
  var removeCellEditor = useCallback(function () {
    setCellEditorValue('');
    setIsEditing(false);
    cellEditorRef.current.style.display = 'none';
  }, []);

  // Remove cell editor if the active cell coordinates change and save with new cell data, this will
  // happen if you click on another cell while isEditing is true
  useEffect(function () {
    var prevCoords = previousState === null || previousState === void 0 ? void 0 : previousState.activeCellCoordinates;
    if (((prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.row) !== (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) || (prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.column) !== (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column)) && isEditing) {
      var cellProps = rows[prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.row].cells[prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.column];
      removeCellEditor();
      updateData(prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.row, cellProps.column.id);
      cellEditorRulerRef.current.textContent = '';
    }
    if ((prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.row) !== (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) || (prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.column) !== (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column)) {
      if (activeCellCoordinates && (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) !== 'header' && (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) !== 'header') {
        var activeCellFullData = typeof (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) === 'number' && typeof (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'number' ? rows[activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row].cells[activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column] : null;
        setActiveCellContent(activeCellFullData.render('Cell'));
      }
      if (activeCellCoordinates && (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'header' || (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) === 'header') {
        setActiveCellContent(null);
      }
    }
  }, [activeCellCoordinates, previousState === null || previousState === void 0 ? void 0 : previousState.activeCellCoordinates, updateData, rows, isEditing, removeCellEditor, activeCellContent]);
  var createActiveCell = useCallback(function (_ref2) {
    var placementElement = _ref2.placementElement,
      coords = _ref2.coords,
      _ref2$addToHeader = _ref2.addToHeader,
      addToHeader = _ref2$addToHeader === void 0 ? false : _ref2$addToHeader;
    var activeCellFullData = typeof (coords === null || coords === void 0 ? void 0 : coords.column) === 'number' && typeof (coords === null || coords === void 0 ? void 0 : coords.row) === 'number' ? rows[coords === null || coords === void 0 ? void 0 : coords.row].cells[coords === null || coords === void 0 ? void 0 : coords.column] : null;
    var activeCellValue = activeCellFullData ? Object.values(activeCellFullData.row.values)[coords === null || coords === void 0 ? void 0 : coords.column] : null;
    var prevCoords = previousState === null || previousState === void 0 ? void 0 : previousState.activeCellCoordinates;
    // Only create an active cell if the activeCellCoordinates have changed
    if ((prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.row) !== (coords === null || coords === void 0 ? void 0 : coords.row) || (prevCoords === null || prevCoords === void 0 ? void 0 : prevCoords.column) !== (coords === null || coords === void 0 ? void 0 : coords.column)) {
      createActiveCellFn({
        placementElement: placementElement,
        coords: coords,
        addToHeader: addToHeader,
        contextRef: spreadsheetRef,
        blockClass: blockClass,
        onActiveCellChange: onActiveCellChange,
        activeCellValue: activeCellValue,
        activeCellRef: activeCellRef,
        cellEditorRef: cellEditorRef,
        defaultColumn: defaultColumn
      });
    }
  }, [spreadsheetRef, rows, onActiveCellChange, previousState === null || previousState === void 0 ? void 0 : previousState.activeCellCoordinates, defaultColumn]);
  useResetSpreadsheetFocus({
    focusedElement: focusedElement,
    removeActiveCell: removeActiveCell,
    setContainerHasFocus: setContainerHasFocus
  });
  useSpreadsheetOutsideClick({
    spreadsheetRef: spreadsheetRef,
    setActiveCellCoordinates: setActiveCellCoordinates,
    setSelectionAreas: setSelectionAreas,
    removeActiveCell: removeActiveCell,
    removeCellSelections: removeCellSelections,
    setContainerHasFocus: setContainerHasFocus,
    removeCellEditor: removeCellEditor
  });
  useMoveActiveCell({
    spreadsheetRef: spreadsheetRef,
    activeCellCoordinates: activeCellCoordinates,
    containerHasFocus: containerHasFocus,
    createActiveCell: createActiveCell
  });
  var handleInitialArrowPress = useCallback(function () {
    // If activeCellCoordinates is null then we need to set an initial value
    // which will place the activeCell on the select all cell/button
    setActiveCellInsideSelectionArea(false);
    if (!activeCellCoordinates) {
      setActiveCellCoordinates({
        column: 'header',
        row: 'header'
      });
    }
    return;
  }, [activeCellCoordinates]);
  var updateActiveCellCoordinates = useCallback(function (_ref3) {
    var _ref3$coords = _ref3.coords,
      coords = _ref3$coords === void 0 ? _objectSpread({}, activeCellCoordinates) : _ref3$coords,
      updatedValue = _ref3.updatedValue,
      _ref3$optOutOfSelecti = _ref3.optOutOfSelectionAreaUpdate,
      optOutOfSelectionAreaUpdate = _ref3$optOutOfSelecti === void 0 ? false : _ref3$optOutOfSelecti;
    var newActiveCell = _objectSpread(_objectSpread({}, coords), updatedValue);
    setActiveCellCoordinates(newActiveCell);
    // Only run if the active cell is _not_ a header cell. This will add a point1 object
    // to selectionAreas every time the active cell changes, allowing us to create cell
    // selections using keyboard. Opting out of the selection area updates here means
    // that the active cell is being moved within a selection area
    if (newActiveCell.row !== 'header' && newActiveCell.column !== 'header' && !optOutOfSelectionAreaUpdate) {
      var tempMatcher = uuidv4();
      setSelectionAreas([{
        point1: newActiveCell,
        matcher: tempMatcher
      }]);
      setCurrentMatcher(tempMatcher);
    }
  }, [activeCellCoordinates]);
  var handleHomeEndKey = useCallback(function (_ref4) {
    var type = _ref4.type;
    var coordinatesClone = _objectSpread({}, activeCellCoordinates);
    updateActiveCellCoordinates({
      coords: coordinatesClone,
      updatedValue: {
        column: type === 'home' ? 0 : columns.length - 1
      }
    });
    removeCellSelections({
      spreadsheetRef: spreadsheetRef
    });
  }, [activeCellCoordinates, updateActiveCellCoordinates, spreadsheetRef, columns.length]);
  var handleKeyPress = useCallback(function (event) {
    var key = event.key;
    if (isEditing) {
      return;
    }
    // Command keys need to be returned as there is default browser behavior with these keys
    if (key === 'Meta' || key === 'Control') {
      return;
    }
    // Prevent arrow keys, home key, and end key from scrolling the page when the data spreadsheet container has focus
    if (['End', 'Home', 'ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown'].indexOf(key) > -1 && !isEditing) {
      event.preventDefault();
    }
    if (['Tab'].indexOf(key) > -1 && isEditing) {
      return;
    }
    // Clear out all cell selection areas if user uses any arrow key, except if the shift key is being held
    if (['ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown'].indexOf(key) > -1) {
      if (selectionAreas !== null && selectionAreas !== void 0 && selectionAreas.length && keysPressedList.length < 2 && !includesShift(keysPressedList)) {
        setSelectionAreas([]);
        setSelectionAreaData([]);
        removeCellSelections({
          spreadsheetRef: spreadsheetRef
        });
      }
    }
    if (!isEditing && (keysPressedList === null || keysPressedList === void 0 ? void 0 : keysPressedList.length) > 1) {
      handleMultipleKeys({
        activeCellCoordinates: activeCellCoordinates,
        event: event,
        keysPressedList: keysPressedList,
        selectionAreas: selectionAreas,
        currentMatcher: currentMatcher,
        rows: rows,
        setSelectionAreas: setSelectionAreas,
        columns: columns,
        updateActiveCellCoordinates: updateActiveCellCoordinates,
        spreadsheetRef: spreadsheetRef,
        removeCellSelections: removeCellSelections,
        blockClass: blockClass,
        setCurrentMatcher: setCurrentMatcher,
        usingMac: usingMac
      });
    }
    var deleteParams = {
      selectionAreas: selectionAreas,
      currentMatcher: currentMatcher,
      rows: rows,
      setActiveCellContent: setActiveCellContent,
      updateData: updateData,
      activeCellCoordinates: activeCellCoordinates
    };
    // Allow arrow key navigation if there are less than two activeKeys OR
    // if one of the activeCellCoordinates is in a header position
    if (keysPressedList.length < 2 && !includesShift(keysPressedList) || activeCellCoordinates.row === 'header' || activeCellCoordinates.column === 'header') {
      switch (key) {
        // Backspace
        case 'Backspace':
          {
            handleCellDeletion(deleteParams);
            break;
          }
        // Delete
        case 'Delete':
          {
            handleCellDeletion(deleteParams);
            break;
          }
        // Enter
        case 'Enter':
          {
            handleActiveCellInSelectionEnter({
              activeCellInsideSelectionArea: activeCellInsideSelectionArea,
              activeCellCoordinates: activeCellCoordinates,
              activeCellRef: activeCellRef,
              selectionAreas: selectionAreas,
              updateActiveCellCoordinates: updateActiveCellCoordinates
            });
            break;
          }
        // HOME
        case 'Home':
          {
            if (includesResourceKey(keysPressedList, usingMac)) {
              return;
            }
            handleHomeEndKey({
              type: 'home'
            });
            break;
          }
        case 'End':
          {
            if (includesResourceKey(keysPressedList, usingMac)) {
              return;
            }
            handleHomeEndKey({
              type: 'end'
            });
            break;
          }
        // Tab
        case 'Tab':
          {
            if (activeCellInsideSelectionArea) {
              event.preventDefault();
              return handleActiveCellInSelectionTab({
                activeCellInsideSelectionArea: activeCellInsideSelectionArea,
                activeCellCoordinates: activeCellCoordinates,
                activeCellRef: activeCellRef,
                selectionAreas: selectionAreas,
                updateActiveCellCoordinates: updateActiveCellCoordinates
              });
            }
            setSelectionAreas([]);
            removeActiveCell();
            removeCellEditor();
            setContainerHasFocus(false);
            setActiveCellCoordinates(null);
            break;
          }
        // Left
        case 'ArrowLeft':
          {
            handleInitialArrowPress();
            var coordinatesClone = _objectSpread({}, activeCellCoordinates);
            if (coordinatesClone.column === 'header') {
              return;
            }
            if (typeof coordinatesClone.column === 'number') {
              if (coordinatesClone.column === 0) {
                updateActiveCellCoordinates({
                  coords: coordinatesClone,
                  updatedValue: {
                    column: 'header'
                  }
                });
                return;
              }
              updateActiveCellCoordinates({
                coords: coordinatesClone,
                updatedValue: {
                  column: coordinatesClone.column - 1
                }
              });
            }
            break;
          }
        // Up
        case 'ArrowUp':
          {
            handleInitialArrowPress();
            var _coordinatesClone = _objectSpread({}, activeCellCoordinates);
            if (_coordinatesClone.row === 'header') {
              return;
            }
            if (typeof _coordinatesClone.row === 'number') {
              // set row back to header if we are at index 0
              if (_coordinatesClone.row === 0) {
                updateActiveCellCoordinates({
                  coords: _coordinatesClone,
                  updatedValue: {
                    row: 'header'
                  }
                });
                return;
              }
              // if we are at any other index than 0, subtract 1 from current row index
              updateActiveCellCoordinates({
                coords: _coordinatesClone,
                updatedValue: {
                  row: _coordinatesClone.row - 1
                }
              });
            }
            break;
          }
        // Right
        case 'ArrowRight':
          {
            handleInitialArrowPress();
            var _coordinatesClone2 = _objectSpread({}, activeCellCoordinates);
            if (_coordinatesClone2.column === 'header') {
              updateActiveCellCoordinates({
                coords: _coordinatesClone2,
                updatedValue: {
                  column: 0
                }
              });
            }
            if (typeof _coordinatesClone2.column === 'number') {
              // Prevent active cell coordinates from updating if the active
              // cell is in the last column, ie we can't go any further to the right
              if (columns.length - 1 === _coordinatesClone2.column) {
                return;
              }
              updateActiveCellCoordinates({
                coords: _coordinatesClone2,
                updatedValue: {
                  column: _coordinatesClone2.column + 1
                }
              });
            }
            break;
          }
        // Down
        case 'ArrowDown':
          {
            handleInitialArrowPress();
            var _coordinatesClone3 = _objectSpread({}, activeCellCoordinates);
            if (_coordinatesClone3.row === 'header') {
              updateActiveCellCoordinates({
                coords: _coordinatesClone3,
                updatedValue: {
                  row: 0
                }
              });
            }
            if (typeof _coordinatesClone3.row === 'number') {
              // Prevent active cell coordinates from updating if the active
              // cell is in the last row, ie we can't go any further down since
              // we are in the last row
              if (rows.length - 1 === _coordinatesClone3.row) {
                return;
              }
              updateActiveCellCoordinates({
                coords: _coordinatesClone3,
                updatedValue: {
                  row: _coordinatesClone3.row + 1
                }
              });
            }
            break;
          }
      }
    }
  }, [activeCellInsideSelectionArea, updateActiveCellCoordinates, handleInitialArrowPress, activeCellCoordinates, removeActiveCell, columns, rows, spreadsheetRef, currentMatcher, isEditing, removeCellEditor, selectionAreas, handleHomeEndKey, keysPressedList, usingMac, updateData]);
  var startEditMode = function startEditMode() {
    setIsEditing(true);
    setClickAndHoldActive(false);
    var activeCellFullData = typeof (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) === 'number' && typeof (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'number' ? rows[activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row].cells[activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column] : null;
    var activeCellValue = activeCellFullData ? activeCellFullData.row.cells[activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column].value : null;
    setCellEditorValue(activeCellValue);
    cellEditorRulerRef.current.textContent = activeCellValue;
    cellEditorRef.current.style.width = activeCellRef === null || activeCellRef === void 0 ? void 0 : activeCellRef.current.style.width;
  };

  // Sets the initial placement of the cell editor cursor at the end of the text area
  // this is not done for us by default in Safari
  useEffect(function () {
    if (isEditing && !(previousState !== null && previousState !== void 0 && previousState.isEditing)) {
      cellEditorRef.current.setSelectionRange(cellEditorRulerRef.current.textContent.length, cellEditorRulerRef.current.textContent.length);
      cellEditorRef.current.focus();
    }
  }, [isEditing, previousState === null || previousState === void 0 ? void 0 : previousState.isEditing]);
  var handleActiveCellClick = function handleActiveCellClick() {
    if ((activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'header' || (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) === 'header') {
      var indexValue = (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'header' ? activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column : activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row;
      if ((activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'header' && (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) === 'header') {
        return;
      }
      handleRowColumnHeaderClick({
        isKeyboard: false,
        index: indexValue
      });
    }
    return;
  };

  // Mouse up on active cell
  var handleActiveCellMouseUp = function handleActiveCellMouseUp() {
    setClickAndHoldActive(false);
  };

  // Mouse down on active cell
  var handleActiveCellMouseDown = function handleActiveCellMouseDown() {
    if ((activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) !== 'header' || (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) !== 'header') {
      var tempMatcher = uuidv4();
      setClickAndHoldActive(true);
      removeCellSelections({
        spreadsheetRef: spreadsheetRef
      });
      setSelectionAreas([{
        point1: activeCellCoordinates,
        matcher: tempMatcher
      }]);
      setCurrentMatcher(tempMatcher);
      setSelectionAreaData([]);
      setActiveCellInsideSelectionArea(false);
    }
    return;
  };

  // Go into edit mode if 'Enter' key is pressed on activeCellRef
  var handleActiveCellKeyDown = function handleActiveCellKeyDown(event) {
    var key = event.key;
    if (key === 'Enter' && !activeCellInsideSelectionArea) {
      if ((activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) !== 'header' && (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) !== 'header') {
        startEditMode();
      }
      if ((activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'header' || (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) === 'header') {
        handleRowColumnHeaderClick({
          isKeyboard: true
        });
      }
    }
  };
  var handleRowColumnHeaderClick = function handleRowColumnHeaderClick(_ref5) {
    var isKeyboard = _ref5.isKeyboard,
      _ref5$index = _ref5.index,
      index = _ref5$index === void 0 ? null : _ref5$index;
    var handleHeaderCellProps = {
      activeCellCoordinates: activeCellCoordinates,
      rows: rows,
      columns: columns,
      setActiveCellCoordinates: setActiveCellCoordinates,
      setCurrentMatcher: setCurrentMatcher,
      setSelectionAreas: setSelectionAreas,
      spreadsheetRef: spreadsheetRef,
      isKeyboard: isKeyboard,
      setSelectionAreaData: setSelectionAreaData,
      index: index,
      currentMatcher: currentMatcher
    };
    // Select an entire column
    if ((activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'header' && (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) !== 'header') {
      handleHeaderCellSelection(_objectSpread({
        type: 'column'
      }, handleHeaderCellProps));
    }
    // Select an entire row
    if ((activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) === 'header' && (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) !== 'header') {
      handleHeaderCellSelection(_objectSpread({
        type: 'row'
      }, handleHeaderCellProps));
    }
    if ((activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) === 'header' && (activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row) === 'header') {
      selectAllCells({
        ref: spreadsheetRef,
        setCurrentMatcher: setCurrentMatcher,
        setSelectionAreas: setSelectionAreas,
        rows: rows,
        columns: columns,
        activeCellCoordinates: activeCellCoordinates,
        updateActiveCellCoordinates: updateActiveCellCoordinates
      });
    }
  };

  // Go into edit mode if double click is detected on activeCellRef
  var handleActiveCellDoubleClick = function handleActiveCellDoubleClick() {
    startEditMode();
  };
  useSpreadsheetEdit({
    isEditing: isEditing,
    rows: rows,
    activeCellCoordinates: activeCellCoordinates,
    activeCellRef: activeCellRef,
    cellEditorRef: cellEditorRef,
    cellEditorRulerRef: cellEditorRulerRef,
    visibleColumns: visibleColumns,
    defaultColumn: defaultColumn,
    cellEditorValue: cellEditorValue
  });

  // Only update if there are cell selection areas
  // Find point object that matches currentMatcher and remove the second point
  // because hovering over the active cell while clicking and holding should
  // remove the previously existing selection area
  var handleActiveCellMouseEnterCallback = useCallback(function (areas, clickHold) {
    if (!currentMatcher) {
      return;
    }
    if (areas && areas.length && clickHold && currentMatcher) {
      setSelectionAreas(function (prev) {
        var selectionAreaClone = deepCloneObject(prev);
        var indexOfItemToUpdate = selectionAreaClone.findIndex(function (item) {
          return item.matcher === currentMatcher;
        });
        if (indexOfItemToUpdate === -1) {
          return prev;
        }
        if (_typeof(selectionAreaClone[indexOfItemToUpdate].point2) === 'object' && selectionAreaClone[indexOfItemToUpdate].areaCreated) {
          selectionAreaClone[indexOfItemToUpdate].point2 = selectionAreaClone[indexOfItemToUpdate].point1;
          selectionAreaClone[indexOfItemToUpdate].areaCreated = false;
          setActiveCellInsideSelectionArea(false);
          removeCellSelections({
            matcher: currentMatcher,
            spreadsheetRef: spreadsheetRef
          });
          return selectionAreaClone;
        }
        return prev;
      });
    }
  }, [spreadsheetRef, currentMatcher]);
  var handleActiveCellMouseEnter = useCallback(function () {
    handleActiveCellMouseEnterCallback(selectionAreas, clickAndHoldActive);
  }, [clickAndHoldActive, selectionAreas, handleActiveCellMouseEnterCallback]);
  return /*#__PURE__*/React.createElement("div", _extends({}, rest, getTableProps(), getDevtoolsProps(componentName), {
    className: cx(blockClass, className, "".concat(blockClass, "--interactive-cell-element"), (_cx = {}, _defineProperty(_cx, "".concat(blockClass, "__container-has-focus"), containerHasFocus), _defineProperty(_cx, "".concat(blockClass, "__").concat(theme), theme === 'dark'), _cx)),
    ref: spreadsheetRef,
    role: "grid",
    tabIndex: 0,
    "aria-rowcount": (rows === null || rows === void 0 ? void 0 : rows.length) || 0,
    "aria-colcount": (columns === null || columns === void 0 ? void 0 : columns.length) || 0,
    "aria-label": spreadsheetAriaLabel,
    onKeyDown: handleKeyPress,
    onFocus: function onFocus() {
      return setContainerHasFocus(true);
    }
  }), /*#__PURE__*/React.createElement("div", {
    ref: multiKeyTrackingRef
  }, /*#__PURE__*/React.createElement(DataSpreadsheetHeader, {
    ref: spreadsheetRef,
    activeCellCoordinates: activeCellCoordinates,
    cellSize: cellSize,
    columns: columns,
    currentMatcher: currentMatcher,
    defaultColumn: defaultColumn,
    headerGroups: headerGroups,
    rows: rows,
    scrollBarSize: scrollBarSize,
    selectionAreas: selectionAreas,
    setActiveCellCoordinates: setActiveCellCoordinates,
    setSelectionAreas: setSelectionAreas,
    setCurrentMatcher: setCurrentMatcher,
    setSelectionAreaData: setSelectionAreaData,
    totalVisibleColumns: totalVisibleColumns,
    updateActiveCellCoordinates: updateActiveCellCoordinates,
    setHeaderCellHoldActive: setHeaderCellHoldActive,
    headerCellHoldActive: headerCellHoldActive,
    visibleColumns: visibleColumns,
    selectAllAriaLabel: selectAllAriaLabel
  }), /*#__PURE__*/React.createElement(DataSpreadsheetBody, {
    activeCellCoordinates: activeCellCoordinates,
    ref: spreadsheetRef,
    clickAndHoldActive: clickAndHoldActive,
    setClickAndHoldActive: setClickAndHoldActive,
    currentMatcher: currentMatcher,
    setCurrentMatcher: setCurrentMatcher,
    setContainerHasFocus: setContainerHasFocus,
    selectionAreas: selectionAreas,
    setSelectionAreas: setSelectionAreas,
    cellSize: cellSize,
    headerGroups: headerGroups,
    defaultColumn: defaultColumn,
    getTableBodyProps: getTableBodyProps,
    onDataUpdate: onDataUpdate,
    onActiveCellChange: onActiveCellChange,
    onSelectionAreaChange: onSelectionAreaChange,
    prepareRow: prepareRow,
    rows: rows,
    selectionAreaData: selectionAreaData,
    setSelectionAreaData: setSelectionAreaData,
    setActiveCellCoordinates: setActiveCellCoordinates,
    scrollBarSize: scrollBarSize,
    totalColumnsWidth: totalColumnsWidth,
    id: id,
    columns: columns,
    defaultEmptyRowCount: defaultEmptyRowCount,
    setActiveCellInsideSelectionArea: setActiveCellInsideSelectionArea,
    totalVisibleColumns: totalVisibleColumns,
    setHeaderCellHoldActive: setHeaderCellHoldActive,
    setColumnOrder: setColumnOrder,
    visibleColumns: visibleColumns
  }), /*#__PURE__*/React.createElement("button", {
    onMouseDown: handleActiveCellMouseDown,
    onMouseUp: handleActiveCellMouseUp,
    onClick: handleActiveCellClick,
    onKeyDown: handleActiveCellKeyDown,
    onDoubleClick: handleActiveCellDoubleClick,
    onMouseEnter: handleActiveCellMouseEnter,
    ref: activeCellRef,
    className: cx("".concat(blockClass, "--interactive-cell-element"), "".concat(blockClass, "__active-cell--highlight"), _defineProperty({}, "".concat(blockClass, "__active-cell--with-selection"), activeCellInsideSelectionArea)),
    type: "button"
  }, activeCellContent), /*#__PURE__*/React.createElement("textarea", {
    id: "".concat(blockClass, "__cell-editor-text-area"),
    value: cellEditorValue,
    onKeyDown: handleEditSubmit({
      activeCellCoordinates: activeCellCoordinates,
      cellEditorRulerRef: cellEditorRulerRef,
      columns: columns,
      previousState: previousState,
      removeCellEditor: removeCellEditor,
      rows: rows,
      setActiveCellCoordinates: setActiveCellCoordinates,
      setCurrentMatcher: setCurrentMatcher,
      setSelectionAreas: setSelectionAreas,
      spreadsheetRef: spreadsheetRef,
      updateData: updateData
    }),
    onChange: function onChange(event) {
      setCellEditorValue(event.target.value);
      cellEditorRulerRef.current.textContent = event.target.value;
    },
    ref: cellEditorRef,
    "aria-labelledby": activeCellCoordinates ? "".concat(blockClass, "__cell--").concat(activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.row, "--").concat(activeCellCoordinates === null || activeCellCoordinates === void 0 ? void 0 : activeCellCoordinates.column) : null,
    className: cx("".concat(blockClass, "__cell-editor"), "".concat(blockClass, "--interactive-cell-element"), "".concat(blockClass, "__cell-editor--").concat(cellSize), _defineProperty({}, "".concat(blockClass, "__cell-editor--active"), isEditing))
  }), /*#__PURE__*/React.createElement("pre", {
    "aria-hidden": true,
    ref: cellEditorRulerRef,
    className: "".concat(blockClass, "__cell-editor-ruler")
  })));
});

// Return a placeholder if not released and not enabled by feature flag
DataSpreadsheet = pkg.checkComponentEnabled(DataSpreadsheet, componentName);

// The display name of the component, used by React. Note that displayName
// is used in preference to relying on function.name.
DataSpreadsheet.displayName = componentName;

// The types and DocGen commentary for the component props,
// in alphabetical order (for consistency).
// See https://www.npmjs.com/package/prop-types#usage.
DataSpreadsheet.propTypes = {
  /**
   * Specifies the cell height
   */
  cellSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg']),
  /**
   * Provide an optional class to be applied to the containing node.
   */
  className: PropTypes.string,
  /**
   * The data that will build the column headers
   */
  columns: PropTypes.arrayOf(PropTypes.shape({
    Header: PropTypes.string,
    accessor: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
    Cell: PropTypes.func // optional cell formatter
  })),

  /**
   * The spreadsheet data that will be rendered in the body of the spreadsheet component
   */
  data: PropTypes.arrayOf(PropTypes.shape),
  /**
   * Sets the number of empty rows to be created when there is no data provided
   */
  defaultEmptyRowCount: PropTypes.number,
  /**
   * The spreadsheet id
   */
  id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  /**
   * The event handler that is called when the active cell changes
   */
  onActiveCellChange: PropTypes.func,
  /**
   * The setter fn for the data prop
   */
  onDataUpdate: PropTypes.func,
  /**
   * The event handler that is called when the selection area values change
   */
  onSelectionAreaChange: PropTypes.func,
  /**
   * The aria label applied to the Select all button
   */
  selectAllAriaLabel: PropTypes.string.isRequired,
  /**
   * The aria label applied to the Data spreadsheet component
   */
  spreadsheetAriaLabel: PropTypes.string.isRequired,
  /**
   * The theme the DataSpreadsheet should use (only used to render active cell/selection area colors on dark theme)
   */
  theme: PropTypes.oneOf(['light', 'dark']),
  /**
   * The total number of columns to be initially visible, additional columns will be rendered and
   * visible via horizontal scrollbar
   */
  totalVisibleColumns: PropTypes.number

  /* TODO: add types and DocGen for all props. */
};