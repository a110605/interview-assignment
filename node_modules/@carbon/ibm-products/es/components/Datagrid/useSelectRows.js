import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["onChange"];
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/*
 * Licensed Materials - Property of IBM
 * 5724-Q36
 * (c) Copyright IBM Corp. 2020
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
// @flow
import React, { useLayoutEffect, useState } from 'react';
import cx from 'classnames';
import { TableSelectRow } from '@carbon/react';
import { SelectAll } from './Datagrid/DatagridSelectAll';
import { selectionColumnId } from './common-column-ids';
import { pkg, carbon } from '../../settings';
var blockClass = "".concat(pkg.prefix, "--datagrid");
var useSelectRows = function useSelectRows(hooks) {
  useHighlightSelection(hooks);
  var useInstance = function useInstance(instance) {
    var rows = instance.rows;
    var rowsWithSelect = rows.map(function (row) {
      return _objectSpread(_objectSpread({}, row), {}, {
        isSelectable: true
      });
    });
    Object.assign(instance, {
      rows: rowsWithSelect
    });
  };
  hooks.useInstance.push(useInstance);
  hooks.useInstance.push(function (instance) {
    Object.assign(instance, {
      withSelectRows: true
    });
  });
  hooks.visibleColumns.push(function (columns) {
    return [{
      id: selectionColumnId,
      Header: function Header(gridState) {
        return /*#__PURE__*/React.createElement(SelectAll, gridState);
      },
      Cell: function Cell(gridState) {
        return /*#__PURE__*/React.createElement(SelectRow, gridState);
      }
    }].concat(_toConsumableArray(columns));
  });
};
var useHighlightSelection = function useHighlightSelection(hooks) {
  var getRowProps = function getRowProps(props, _ref) {
    var row = _ref.row;
    return [props, {
      className: cx("".concat(blockClass, "__carbon-row"), row.getToggleRowSelectedProps().checked ? "".concat(carbon.prefix, "--data-table--selected ").concat(blockClass, "__active-row") : '')
    }];
  };
  hooks.getRowProps.push(getRowProps);
};
var SelectRow = function SelectRow(datagridState) {
  var _columns$;
  var _datagridState$isFetc = datagridState.isFetching,
    isFetching = _datagridState$isFetc === void 0 ? false : _datagridState$isFetc,
    tableId = datagridState.tableId,
    row = datagridState.row,
    cell = datagridState.cell,
    radio = datagridState.radio,
    toggleAllRowsSelected = datagridState.toggleAllRowsSelected,
    onRadioSelect = datagridState.onRadioSelect,
    onRowSelect = datagridState.onRowSelect,
    columns = datagridState.columns,
    withStickyColumn = datagridState.withStickyColumn;
  var _useState = useState(window.innerWidth),
    _useState2 = _slicedToArray(_useState, 2),
    windowSize = _useState2[0],
    setWindowSize = _useState2[1];
  useLayoutEffect(function () {
    function updateSize() {
      setWindowSize(window.innerWidth);
    }
    window.addEventListener('resize', updateSize);
    return function () {
      return window.removeEventListener('resize', updateSize);
    };
  }, []);
  var selectDisabled = isFetching || row.getRowProps().selectDisabled;
  var _row$getToggleRowSele = row.getToggleRowSelectedProps(),
    onChange = _row$getToggleRowSele.onChange,
    selectProps = _objectWithoutProperties(_row$getToggleRowSele, _excluded);
  var cellProps = cell.getCellProps();
  var isFirstColumnStickyLeft = ((_columns$ = columns[0]) === null || _columns$ === void 0 ? void 0 : _columns$.sticky) === 'left' && withStickyColumn;
  return /*#__PURE__*/React.createElement(TableSelectRow, _extends({}, cellProps, selectProps, {
    radio: radio,
    onSelect: function onSelect(e) {
      e.stopPropagation(); // avoid triggering onRowClick
      if (radio) {
        toggleAllRowsSelected(false);
        if (onRadioSelect) {
          onRadioSelect(row);
        }
      }
      onChange(e);
      onRowSelect === null || onRowSelect === void 0 ? void 0 : onRowSelect(row, e);
    },
    id: "".concat(tableId, "-").concat(row.index),
    name: "".concat(tableId, "-").concat(row.index, "-name"),
    className: cx("".concat(blockClass, "__checkbox-cell"), cellProps.className, _defineProperty({}, "".concat(blockClass, "__checkbox-cell-sticky-left"), isFirstColumnStickyLeft && windowSize > 671)),
    ariaLabel: "".concat(tableId, "-row-").concat(row.index) // TODO: aria label should be i18n'ed
    ,
    disabled: selectDisabled
  }));
};
export default useSelectRows;