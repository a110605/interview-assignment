import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
/**
 * Copyright IBM Corp. 2022, 2022
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

import React, { useContext, useEffect, useRef } from 'react';
import cx from 'classnames';
import PropTypes from 'prop-types';
import { TableContainer, Table } from '@carbon/react';
import { px } from '@carbon/layout';
import DatagridHead from './DatagridHead';
import DatagridBody from './DatagridBody';
import DatagridToolbar from './DatagridToolbar';
import { handleGridKeyPress } from './addons/InlineEdit/handleGridKeyPress';
import { carbon, pkg } from '../../../settings';
import { InlineEditContext } from './addons/InlineEdit/InlineEditContext';
import { FilterContext, FilterPanel } from './addons/Filtering';
import { handleGridFocus } from './addons/InlineEdit/handleGridFocus';
import { useClickOutside } from '../../../global/js/hooks';
import { useMultipleKeyTracking } from '../../DataSpreadsheet/hooks';
import { FilterSummary } from '../../FilterSummary';
import { CLEAR_FILTERS } from './addons/Filtering/constants';
var blockClass = "".concat(pkg.prefix, "--datagrid");
export var DatagridContent = function DatagridContent(_ref) {
  var _cx4;
  var datagridState = _ref.datagridState;
  var _useContext = useContext(InlineEditContext),
    inlineEditState = _useContext.state,
    dispatch = _useContext.dispatch;
  var _useContext2 = useContext(FilterContext),
    filterTags = _useContext2.filterTags,
    EventEmitter = _useContext2.EventEmitter,
    panelOpen = _useContext2.panelOpen;
  var activeCellId = inlineEditState.activeCellId,
    gridActive = inlineEditState.gridActive,
    editId = inlineEditState.editId;
  var _datagridState$getTab = datagridState.getTableProps,
    getTableProps = _datagridState$getTab === void 0 ? function () {} : _datagridState$getTab,
    getFilterFlyoutProps = datagridState.getFilterFlyoutProps,
    withVirtualScroll = datagridState.withVirtualScroll,
    DatagridPagination = datagridState.DatagridPagination,
    isFetching = datagridState.isFetching,
    CustomizeColumnsTearsheet = datagridState.CustomizeColumnsTearsheet,
    filterProps = datagridState.filterProps,
    fullHeightDatagrid = datagridState.fullHeightDatagrid,
    _datagridState$vertic = datagridState.verticalAlign,
    verticalAlign = _datagridState$vertic === void 0 ? 'center' : _datagridState$vertic,
    variableRowHeight = datagridState.variableRowHeight,
    gridTitle = datagridState.gridTitle,
    gridDescription = datagridState.gridDescription,
    useDenseHeader = datagridState.useDenseHeader,
    withInlineEdit = datagridState.withInlineEdit,
    tableId = datagridState.tableId,
    DatagridActions = datagridState.DatagridActions,
    totalColumnsWidth = datagridState.totalColumnsWidth,
    gridRef = datagridState.gridRef,
    state = datagridState.state;
  var rows = DatagridPagination && datagridState.page || datagridState.rows;
  var gridAreaRef = useRef();
  var multiKeyTrackingRef = useRef();
  useClickOutside(gridAreaRef, function (target) {
    if (!withInlineEdit) {
      return;
    }
    // We return from here if we find a parent element with the selector below
    // because that element was initially part of the grid area but was removed
    // and swapped out with an input, i.e. text, number, selection, or date picker
    if (target.closest(".".concat(blockClass, "__inline-edit-button")) || target.closest(".".concat(blockClass, "__inline-edit--select"))) {
      return;
    }
    dispatch({
      type: 'REMOVE_GRID_ACTIVE_FOCUS',
      payload: activeCellId
    });
  });
  var renderTable = function renderTable() {
    var _getTableProps;
    return /*#__PURE__*/React.createElement(Table, _extends({}, getTableProps(), {
      className: cx(withVirtualScroll ? '' : "".concat(blockClass, "__table-simple"), "".concat(blockClass, "__vertical-align-").concat(verticalAlign), _defineProperty({}, "".concat(blockClass, "__variable-row-height"), variableRowHeight), _defineProperty({}, "".concat(blockClass, "__table-with-inline-edit"), withInlineEdit), _defineProperty({}, "".concat(blockClass, "__table-grid-active"), gridActive), (_getTableProps = getTableProps()) === null || _getTableProps === void 0 ? void 0 : _getTableProps.className),
      role: withInlineEdit && 'grid',
      tabIndex: withInlineEdit ? 0 : -1,
      onKeyDown: withInlineEdit ? function (event) {
        return handleGridKeyPress({
          event: event,
          dispatch: dispatch,
          instance: datagridState,
          keysPressedList: keysPressedList,
          state: inlineEditState,
          usingMac: usingMac
        });
      } : null,
      onFocus: withInlineEdit ? function () {
        return handleGridFocus(inlineEditState, dispatch);
      } : null
    }), !withVirtualScroll ? /*#__PURE__*/React.createElement(DatagridHead, datagridState) : null, /*#__PURE__*/React.createElement(DatagridBody, _extends({}, datagridState, {
      rows: rows
    })));
  };
  var _useMultipleKeyTracki = useMultipleKeyTracking({
      ref: withInlineEdit ? multiKeyTrackingRef : null,
      containerHasFocus: gridActive,
      isEditing: !!editId
    }),
    keysPressedList = _useMultipleKeyTracki.keysPressedList,
    usingMac = _useMultipleKeyTracki.usingMac;

  // Provides a width for the region outline for useInlineEdit
  useEffect(function () {
    if (!withInlineEdit) {
      return;
    }
    var gridElement = document.querySelector("#".concat(tableId));
    var tableHeader = gridElement === null || gridElement === void 0 ? void 0 : gridElement.querySelector(".".concat(carbon.prefix, "--data-table-header"));
    gridElement.style.setProperty("--".concat(blockClass, "--grid-width"), px(totalColumnsWidth + 32));
    if (gridActive) {
      gridElement.style.setProperty("--".concat(blockClass, "--grid-header-height"), px((tableHeader === null || tableHeader === void 0 ? void 0 : tableHeader.clientHeight) || 0));
    }
  }, [withInlineEdit, tableId, totalColumnsWidth, datagridState, gridActive]);
  var renderFilterSummary = function renderFilterSummary() {
    return state.filters.length > 0 && /*#__PURE__*/React.createElement(FilterSummary, {
      className: "".concat(blockClass, "__filter-summary"),
      filters: filterTags,
      clearFilters: function clearFilters() {
        return EventEmitter.dispatch(CLEAR_FILTERS);
      }
    });
  };
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(TableContainer, {
    className: cx("".concat(blockClass, "__grid-container"), withVirtualScroll || fullHeightDatagrid ? "".concat(blockClass, "__full-height") : '', DatagridPagination ? "".concat(blockClass, "__with-pagination") : '', useDenseHeader ? "".concat(blockClass, "__dense-header") : '', (_cx4 = {}, _defineProperty(_cx4, "".concat(blockClass, "__grid-container-grid-active"), gridActive), _defineProperty(_cx4, "".concat(blockClass, "__grid-container-inline-edit"), withInlineEdit), _defineProperty(_cx4, "".concat(blockClass, "__grid-container-grid-active--without-toolbar"), withInlineEdit && !DatagridActions), _cx4)),
    title: gridTitle,
    description: gridDescription
  }, /*#__PURE__*/React.createElement(DatagridToolbar, datagridState), /*#__PURE__*/React.createElement("div", {
    className: cx("".concat(blockClass, "__table-container"), _defineProperty({}, "".concat(blockClass, "__table-container--filter-open"), panelOpen)),
    ref: gridAreaRef
  }, (filterProps === null || filterProps === void 0 ? void 0 : filterProps.variation) === 'panel' && /*#__PURE__*/React.createElement(FilterPanel, _extends({
    updateMethod: "batch"
  }, getFilterFlyoutProps(), {
    title: filterProps.panelTitle,
    filterSections: filterProps.sections
  })), /*#__PURE__*/React.createElement("div", {
    className: "".concat(blockClass, "__table-container-inner")
  }, renderFilterSummary(), withInlineEdit ? /*#__PURE__*/React.createElement("div", {
    ref: multiKeyTrackingRef
  }, renderTable()) : withVirtualScroll ? /*#__PURE__*/React.createElement("div", {
    className: "".concat(blockClass, "__virtualScrollContainer"),
    ref: gridRef
  }, renderTable()) : renderTable()))), (rows === null || rows === void 0 ? void 0 : rows.length) > 0 && !isFetching && DatagridPagination && /*#__PURE__*/React.createElement(DatagridPagination, datagridState), CustomizeColumnsTearsheet && /*#__PURE__*/React.createElement(CustomizeColumnsTearsheet, {
    instance: datagridState
  }));
};
DatagridContent.propTypes = {
  datagridState: PropTypes.shape({
    getTableProps: PropTypes.func,
    getFilterFlyoutProps: PropTypes.func,
    withVirtualScroll: PropTypes.bool,
    DatagridActions: PropTypes.oneOfType([PropTypes.element, PropTypes.func]),
    DatagridPagination: PropTypes.oneOfType([PropTypes.element, PropTypes.func]),
    CustomizeColumnsTearsheet: PropTypes.oneOfType([PropTypes.element, PropTypes.func]),
    isFetching: PropTypes.bool,
    fullHeightDatagrid: PropTypes.bool,
    filterProps: PropTypes.object,
    variableRowHeight: PropTypes.bool,
    useDenseHeader: PropTypes.bool,
    withInlineEdit: PropTypes.bool,
    verticalAlign: PropTypes.string,
    gridTitle: PropTypes.node,
    gridDescription: PropTypes.node,
    page: PropTypes.arrayOf(PropTypes.object),
    rows: PropTypes.arrayOf(PropTypes.object),
    tableId: PropTypes.string,
    totalColumnsWidth: PropTypes.number,
    gridRef: PropTypes.object,
    setAllFilters: PropTypes.func,
    getFilterProps: PropTypes.func,
    state: PropTypes.object
  })
};