import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/*
 * Licensed Materials - Property of IBM
 * 5724-Q36
 * (c) Copyright IBM Corp. 2023
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
import React, { useState, useRef, useEffect } from 'react';
import { Checkbox, DatePicker, DatePickerInput, Dropdown, FormGroup, NumberInput, RadioButton, RadioButtonGroup, Layer } from '@carbon/react';
import { INSTANT, BATCH, DATE, CHECKBOX, NUMBER, RADIO, DROPDOWN, PANEL } from '../constants';
import { getInitialStateFromFilters } from '../utils';
var useFilters = function useFilters(_ref) {
  var updateMethod = _ref.updateMethod,
    _ref$filters = _ref.filters,
    filters = _ref$filters === void 0 ? [] : _ref$filters,
    setAllFilters = _ref.setAllFilters,
    variation = _ref.variation,
    reactTableFiltersState = _ref.reactTableFiltersState,
    _ref$onCancel = _ref.onCancel,
    onCancel = _ref$onCancel === void 0 ? function () {} : _ref$onCancel;
  /** State */
  var _useState = useState(getInitialStateFromFilters(filters, variation, reactTableFiltersState)),
    _useState2 = _slicedToArray(_useState, 2),
    filtersState = _useState2[0],
    setFiltersState = _useState2[1];
  var _useState3 = useState(reactTableFiltersState),
    _useState4 = _slicedToArray(_useState3, 2),
    filtersObjectArray = _useState4[0],
    setFiltersObjectArray = _useState4[1];

  // When using batch actions we have to store the filters to then apply them later
  var prevFiltersRef = useRef(JSON.stringify(filtersState));
  var lastAppliedFilters = useRef(JSON.stringify(reactTableFiltersState));
  var prevFiltersObjectArrayRef = useRef(JSON.stringify(filtersObjectArray));

  /** Methods */
  // If the user decides to cancel or click outside the flyout, it reverts back to the filters that were
  // there when they opened the flyout
  var revertToPreviousFilters = function revertToPreviousFilters() {
    setFiltersState(JSON.parse(prevFiltersRef.current));
    setFiltersObjectArray(JSON.parse(prevFiltersObjectArrayRef.current));
    setAllFilters(JSON.parse(lastAppliedFilters.current));
  };
  var reset = function reset() {
    // When we reset we want the "initialFilters" to be an empty array
    var resetFiltersArray = [];

    // Get the initial values for the filters
    var initialFiltersState = getInitialStateFromFilters(filters, variation, resetFiltersArray);
    var initialFiltersObjectArray = [];

    // Set the state to the initial values
    setFiltersState(initialFiltersState);
    setFiltersObjectArray(initialFiltersObjectArray);
    setAllFilters([]);

    // Update their respective refs so everything is in sync
    prevFiltersRef.current = JSON.stringify(initialFiltersState);
    prevFiltersObjectArrayRef.current = JSON.stringify(initialFiltersObjectArray);
  };
  var applyFilters = function applyFilters(_ref2) {
    var column = _ref2.column,
      value = _ref2.value,
      type = _ref2.type;
    // If no end date is selected return because we need the end date to do computations
    if (type === DATE && value.length > 0 && !value[1]) {
      return;
    }
    var filtersObjectArrayCopy = _toConsumableArray(filtersObjectArray);
    // // check if the filter already exists in the array
    var filter = filtersObjectArrayCopy.find(function (item) {
      return item.id === column;
    });

    // // if filter exists in array then update the filter's new value
    if (filter) {
      filter.value = value;
    } else {
      filtersObjectArrayCopy.push({
        id: column,
        value: value,
        type: type
      });
    }

    // ATTENTION: this is where you would reset or remove individual filters from the filters array
    if (type === CHECKBOX) {
      /**
      When all checkboxes of a group are all unselected the value still exists in the filtersObjectArray
      This checks if all the checkboxes are selected = false and removes it from the array
      */
      var index = filtersObjectArrayCopy.findIndex(function (filter) {
        return filter.id === column;
      });

      // If all the selected state is false remove from array
      var shouldRemoveFromArray = filtersObjectArrayCopy[index].value.every(function (val) {
        return val.selected === false;
      });
      if (shouldRemoveFromArray) {
        filtersObjectArrayCopy.splice(index, 1);
      }
    } else if (type === DATE) {
      if (value.length === 0) {
        /**
        Checks to see if the date value is an empty array, if it is that means the user wants
        to reset the date filter
        */
        var _index = filtersObjectArrayCopy.findIndex(function (filter) {
          return filter.id === column;
        });

        // Remove it from the filters array since there is nothing to filter
        filtersObjectArrayCopy.splice(_index, 1);
      }
    } else if (type === DROPDOWN || type === RADIO) {
      if (value === 'Any') {
        /**
        Checks to see if the selected value is 'Any', that means the user wants
        to reset specific filter
        */
        var _index2 = filtersObjectArrayCopy.findIndex(function (filter) {
          return filter.id === column;
        });

        // Remove it from the filters array
        filtersObjectArrayCopy.splice(_index2, 1);
      }
    } else if (type === NUMBER) {
      // If the value is empty remove it from the filtersObjectArray
      if (value === '') {
        // Find the column that uses number and displays an empty string
        var _index3 = filtersObjectArrayCopy.findIndex(function (filter) {
          return filter.id === column;
        });

        // Remove it from the filters array
        filtersObjectArrayCopy.splice(_index3, 1);
      }
    }
    setFiltersObjectArray(filtersObjectArrayCopy);

    // // Automatically apply the filters if the updateMethod is instant
    if (updateMethod === INSTANT) {
      setAllFilters(filtersObjectArrayCopy);
    }
  };
  /** Render the individual filter component */
  var renderFilter = function renderFilter(_ref3) {
    var _filtersState$column, _filtersState$column2, _filtersState$column3, _filtersState$column4;
    var type = _ref3.type,
      column = _ref3.column,
      components = _ref3.props;
    var filter;
    var isPanel = variation === PANEL;
    if (!type) {
      return console.error("type: ".concat(type, "; does not exist as a type of filter."));
    }
    switch (type) {
      case DATE:
        filter = /*#__PURE__*/React.createElement(DatePicker, _extends({}, components.DatePicker, {
          onChange: function onChange(value) {
            var _components$DatePicke, _components$DatePicke2;
            setFiltersState(_objectSpread(_objectSpread({}, filtersState), {}, _defineProperty({}, column, {
              value: value,
              type: type
            })));
            applyFilters({
              column: column,
              value: value,
              type: type
            });
            (_components$DatePicke = (_components$DatePicke2 = components.DatePicker).onChange) === null || _components$DatePicke === void 0 ? void 0 : _components$DatePicke.call(_components$DatePicke2, value);
          },
          value: filtersState[column].value,
          datePickerType: "range"
        }), /*#__PURE__*/React.createElement(DatePickerInput, _extends({
          placeholder: "mm/dd/yyyy",
          labelText: "Start date"
        }, components.DatePickerInput.start)), /*#__PURE__*/React.createElement(DatePickerInput, _extends({
          placeholder: "mm/dd/yyyy",
          labelText: "End date"
        }, components.DatePickerInput.end)));
        break;
      case NUMBER:
        filter = /*#__PURE__*/React.createElement(NumberInput, _extends({
          step: 1,
          allowEmpty: true,
          hideSteppers: true
        }, components.NumberInput, {
          onChange: function onChange(event) {
            var _components$NumberInp, _components$NumberInp2;
            setFiltersState(_objectSpread(_objectSpread({}, filtersState), {}, _defineProperty({}, column, {
              value: event.target.value,
              type: type
            })));
            applyFilters({
              column: column,
              value: event.target.value,
              type: type
            });
            (_components$NumberInp = (_components$NumberInp2 = components.NumberInput).onChange) === null || _components$NumberInp === void 0 ? void 0 : _components$NumberInp.call(_components$NumberInp2, event);
          },
          value: filtersState[column].value
        }));
        break;
      case CHECKBOX:
        filter = /*#__PURE__*/React.createElement(FormGroup, components.FormGroup, filtersState[column].value.map(function (option) {
          return /*#__PURE__*/React.createElement(Checkbox, _extends({
            key: option.labelText
          }, option, {
            onChange: function onChange(_, _ref4) {
              var _option$onChange;
              var isSelected = _ref4.checked;
              var checkboxCopy = filtersState[column].value;
              var foundCheckbox = checkboxCopy.find(function (checkbox) {
                return checkbox.value === option.value;
              });
              foundCheckbox.selected = isSelected;
              setFiltersState(_objectSpread(_objectSpread({}, filtersState), {}, _defineProperty({}, column, {
                value: checkboxCopy,
                type: type
              })));
              applyFilters({
                column: column,
                value: _toConsumableArray(filtersState[column].value),
                type: type
              });
              (_option$onChange = option.onChange) === null || _option$onChange === void 0 ? void 0 : _option$onChange.call(option, isSelected);
            },
            checked: option.selected
          }));
        }));
        break;
      case RADIO:
        filter = /*#__PURE__*/React.createElement(FormGroup, components.FormGroup, /*#__PURE__*/React.createElement(RadioButtonGroup, _extends({}, components.RadioButtonGroup, {
          valueSelected: ((_filtersState$column = filtersState[column]) === null || _filtersState$column === void 0 ? void 0 : _filtersState$column.value) === '' ? 'Any' : (_filtersState$column2 = filtersState[column]) === null || _filtersState$column2 === void 0 ? void 0 : _filtersState$column2.value,
          onChange: function onChange(selected) {
            var _components$RadioButt, _components$RadioButt2;
            setFiltersState(_objectSpread(_objectSpread({}, filtersState), {}, _defineProperty({}, column, {
              value: selected,
              type: type
            })));
            applyFilters({
              column: column,
              value: selected,
              type: type
            });
            (_components$RadioButt = (_components$RadioButt2 = components.RadioButtonGroup).onChange) === null || _components$RadioButt === void 0 ? void 0 : _components$RadioButt.call(_components$RadioButt2, selected);
          }
        }), /*#__PURE__*/React.createElement(RadioButton, {
          id: "any",
          labelText: "Any",
          value: "Any"
        }), components.RadioButton.map(function (radio) {
          var _ref5, _radio$id;
          return /*#__PURE__*/React.createElement(RadioButton, _extends({
            key: (_ref5 = (_radio$id = radio.id) !== null && _radio$id !== void 0 ? _radio$id : radio.labelText) !== null && _ref5 !== void 0 ? _ref5 : radio.value
          }, radio));
        })));
        break;
      case DROPDOWN:
        filter = /*#__PURE__*/React.createElement(Dropdown, _extends({}, components.Dropdown, {
          selectedItem: ((_filtersState$column3 = filtersState[column]) === null || _filtersState$column3 === void 0 ? void 0 : _filtersState$column3.value) === '' ? 'Any' : (_filtersState$column4 = filtersState[column]) === null || _filtersState$column4 === void 0 ? void 0 : _filtersState$column4.value,
          items: ['Any'].concat(_toConsumableArray(components.Dropdown.items)),
          onChange: function onChange(_ref6) {
            var _components$Dropdown$, _components$Dropdown;
            var selectedItem = _ref6.selectedItem;
            setFiltersState(_objectSpread(_objectSpread({}, filtersState), {}, _defineProperty({}, column, {
              value: selectedItem,
              type: type
            })));
            applyFilters({
              column: column,
              value: selectedItem,
              type: type
            });
            (_components$Dropdown$ = (_components$Dropdown = components.Dropdown).onChange) === null || _components$Dropdown$ === void 0 ? void 0 : _components$Dropdown$.call(_components$Dropdown, selectedItem);
          }
        }));
        break;
    }
    if (isPanel) {
      return /*#__PURE__*/React.createElement(Layer, {
        key: column
      }, filter);
    }
    return /*#__PURE__*/React.createElement(React.Fragment, {
      key: column
    }, filter);
  };
  var cancel = function cancel() {
    // Reverting to previous filters only applies when using batch actions
    if (updateMethod === BATCH) {
      revertToPreviousFilters();
      onCancel();
    }
  };

  /** The purpose of this function is to sync any changes in react-tables state.filters array and reflect
      those new filter changes in the panel/flyout state. The external change is triggered if setAllFilters is called outside of the Datagrid */
  useEffect(function updateStateAndFiltersToReflectExternalFilterChanges() {
    var newFiltersState = getInitialStateFromFilters(filters, variation, reactTableFiltersState);
    setFiltersState(newFiltersState);
    prevFiltersRef.current = JSON.stringify(newFiltersState);
    prevFiltersObjectArrayRef.current = JSON.stringify(reactTableFiltersState);
    setFiltersObjectArray(reactTableFiltersState);
  }, [filters, reactTableFiltersState, variation]);
  return {
    filtersState: filtersState,
    setFiltersState: setFiltersState,
    prevFiltersObjectArrayRef: prevFiltersObjectArrayRef,
    prevFiltersRef: prevFiltersRef,
    revertToPreviousFilters: revertToPreviousFilters,
    reset: reset,
    renderFilter: renderFilter,
    filtersObjectArray: filtersObjectArray,
    lastAppliedFilters: lastAppliedFilters,
    cancel: cancel
  };
};
export default useFilters;