import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
// @flow
/**
 * Copyright IBM Corp. 2022, 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

import { Filter } from '@carbon/react/icons';
import { IconButton, usePrefix } from '@carbon/react';
import cx from 'classnames';
import PropTypes from 'prop-types';
import React, { useRef, useState, useEffect } from 'react';
import { useClickOutside } from '../../../../../global/js/hooks';
import { pkg } from '../../../../../settings';
import { ActionSet } from '../../../../ActionSet';
import { BATCH, CLEAR_FILTERS, FLYOUT, INSTANT } from './constants';
import { useSubscribeToEventEmitter, useFilters, useShouldDisableButtons } from './hooks';
var blockClass = "".concat(pkg.prefix, "--datagrid");
var componentClass = "".concat(blockClass, "-filter-flyout");
var FilterFlyout = function FilterFlyout(_ref) {
  var _cx2;
  var _ref$updateMethod = _ref.updateMethod,
    updateMethod = _ref$updateMethod === void 0 ? BATCH : _ref$updateMethod,
    _ref$flyoutIconDescri = _ref.flyoutIconDescription,
    flyoutIconDescription = _ref$flyoutIconDescri === void 0 ? 'Open filters' : _ref$flyoutIconDescri,
    _ref$filters = _ref.filters,
    filters = _ref$filters === void 0 ? [] : _ref$filters,
    _ref$title = _ref.title,
    title = _ref$title === void 0 ? 'Filter' : _ref$title,
    _ref$primaryActionLab = _ref.primaryActionLabel,
    primaryActionLabel = _ref$primaryActionLab === void 0 ? 'Apply' : _ref$primaryActionLab,
    _ref$onFlyoutOpen = _ref.onFlyoutOpen,
    onFlyoutOpen = _ref$onFlyoutOpen === void 0 ? function () {} : _ref$onFlyoutOpen,
    _ref$onFlyoutClose = _ref.onFlyoutClose,
    onFlyoutClose = _ref$onFlyoutClose === void 0 ? function () {} : _ref$onFlyoutClose,
    _ref$onApply = _ref.onApply,
    onApply = _ref$onApply === void 0 ? function () {} : _ref$onApply,
    _ref$onCancel = _ref.onCancel,
    onCancel = _ref$onCancel === void 0 ? function () {} : _ref$onCancel,
    _ref$secondaryActionL = _ref.secondaryActionLabel,
    secondaryActionLabel = _ref$secondaryActionL === void 0 ? 'Cancel' : _ref$secondaryActionL,
    setAllFilters = _ref.setAllFilters,
    _ref$data = _ref.data,
    data = _ref$data === void 0 ? [] : _ref$data,
    _ref$reactTableFilter = _ref.reactTableFiltersState,
    reactTableFiltersState = _ref$reactTableFilter === void 0 ? [] : _ref$reactTableFilter;
  /** State */
  var _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    open = _useState2[0],
    setOpen = _useState2[1];
  var _useFilters = useFilters({
      updateMethod: updateMethod,
      filters: filters,
      setAllFilters: setAllFilters,
      variation: FLYOUT,
      reactTableFiltersState: reactTableFiltersState,
      onCancel: onCancel
    }),
    filtersState = _useFilters.filtersState,
    prevFiltersObjectArrayRef = _useFilters.prevFiltersObjectArrayRef,
    prevFiltersRef = _useFilters.prevFiltersRef,
    cancel = _useFilters.cancel,
    reset = _useFilters.reset,
    renderFilter = _useFilters.renderFilter,
    filtersObjectArray = _useFilters.filtersObjectArray,
    lastAppliedFilters = _useFilters.lastAppliedFilters;

  /** Refs */
  var filterFlyoutRef = useRef(null);

  /** State from hooks */
  var _useShouldDisableButt = useShouldDisableButtons({
      initialValue: true,
      filtersState: filtersState,
      prevFiltersRef: prevFiltersRef
    }),
    _useShouldDisableButt2 = _slicedToArray(_useShouldDisableButt, 2),
    shouldDisableButtons = _useShouldDisableButt2[0],
    setShouldDisableButtons = _useShouldDisableButt2[1];

  /** Memos */
  var showActionSet = updateMethod === BATCH;
  var carbonPrefix = usePrefix();

  /** Methods */
  var openFlyout = function openFlyout() {
    setOpen(true);
    onFlyoutOpen();
  };
  var closeFlyout = function closeFlyout() {
    setOpen(false);
    onFlyoutClose();
  };
  var apply = function apply() {
    setAllFilters(filtersObjectArray);
    closeFlyout();
    // From the user
    onApply();
    // When the user clicks apply, the action set buttons should be disabled again
    setShouldDisableButtons(true);

    // updates the ref so next time the flyout opens we have records of the previous filters
    prevFiltersRef.current = JSON.stringify(filtersState);
    prevFiltersObjectArrayRef.current = JSON.stringify(filtersObjectArray);

    // Update the last applied filters
    lastAppliedFilters.current = JSON.stringify(filtersObjectArray);
  };

  /** Renders all filters */
  var renderFilters = function renderFilters() {
    return filters.map(renderFilter);
  };
  var renderActionSet = function renderActionSet() {
    return showActionSet && /*#__PURE__*/React.createElement(ActionSet, {
      actions: [{
        key: 1,
        kind: 'primary',
        label: primaryActionLabel,
        onClick: apply,
        isExpressive: false,
        disabled: shouldDisableButtons
      }, {
        key: 3,
        kind: 'secondary',
        label: secondaryActionLabel,
        onClick: cancel,
        isExpressive: false,
        disabled: shouldDisableButtons
      }],
      size: "md",
      buttonSize: "md"
    });
  };

  /** Effects */
  useClickOutside(filterFlyoutRef, function (target) {
    var hasClickedOnDatePicker = target.closest('.flatpickr-calendar');
    var hasClickedOnDropdown = target.className === "".concat(carbonPrefix, "--list-box__menu-item__option");
    if (!open || hasClickedOnDatePicker || hasClickedOnDropdown) {
      return;
    }
    closeFlyout();
    cancel();
  });
  useSubscribeToEventEmitter(CLEAR_FILTERS, reset);
  useEffect(function reflectLastAppliedFiltersWhenReactTableUpdates() {
    lastAppliedFilters.current = JSON.stringify(reactTableFiltersState);
  }, [reactTableFiltersState, lastAppliedFilters]);
  return /*#__PURE__*/React.createElement("div", {
    className: "".concat(componentClass, "__container")
  }, /*#__PURE__*/React.createElement(IconButton, {
    label: flyoutIconDescription,
    kind: "ghost",
    align: "bottom",
    onClick: open ? closeFlyout : openFlyout,
    className: cx("".concat(componentClass, "__trigger"), _defineProperty({}, "".concat(componentClass, "__trigger--open"), open)),
    disabled: data.length === 0
  }, /*#__PURE__*/React.createElement(Filter, null)), /*#__PURE__*/React.createElement("div", {
    ref: filterFlyoutRef,
    className: cx(componentClass, (_cx2 = {}, _defineProperty(_cx2, "".concat(componentClass, "--open"), open), _defineProperty(_cx2, "".concat(componentClass, "--batch"), showActionSet), _defineProperty(_cx2, "".concat(componentClass, "--instant"), !showActionSet), _cx2))
  }, /*#__PURE__*/React.createElement("div", {
    className: "".concat(componentClass, "__inner-container")
  }, /*#__PURE__*/React.createElement("span", {
    className: "".concat(componentClass, "__title")
  }, title), /*#__PURE__*/React.createElement("div", {
    className: "".concat(componentClass, "__filters")
  }, renderFilters())), renderActionSet()));
};
FilterFlyout.propTypes = {
  /**
   * All data rows in the table
   */
  data: PropTypes.array.isRequired,
  /**
   * Array of filters to render
   */
  filters: PropTypes.arrayOf(PropTypes.shape({
    type: PropTypes.string.isRequired,
    column: PropTypes.string.isRequired,
    props: PropTypes.object.isRequired
  })).isRequired,
  /**
   * Icon description for the filter flyout button
   */
  flyoutIconDescription: PropTypes.string,
  /**
   * Callback when the apply button is clicked
   */
  onApply: PropTypes.func,
  /**
   * Callback when the cancel button is clicked
   */
  onCancel: PropTypes.func,
  /**
   * Callback when the flyout closes
   */
  onFlyoutClose: PropTypes.func,
  /**
   * Callback when the flyout opens
   */
  onFlyoutOpen: PropTypes.func,
  /**
   * Label text of the primary action in the flyout
   */
  primaryActionLabel: PropTypes.string,
  /**
   * Filters from react table's state
   */
  reactTableFiltersState: PropTypes.arrayOf(PropTypes.shape({
    id: PropTypes.string.isRequired,
    type: PropTypes.string.isRequired,
    value: PropTypes.any.isRequired
  })),
  /**
   * Label text of the secondary action in the flyout
   */
  secondaryActionLabel: PropTypes.string,
  /**
   * Function that sets all the filters, this comes from the datagridState
   */
  setAllFilters: PropTypes.func.isRequired,
  /**
   * Title of the filter flyout
   */
  title: PropTypes.string,
  /**
   * The update method used to apply the filters
   */
  updateMethod: PropTypes.oneOf([BATCH, INSTANT]).isRequired
};
export default FilterFlyout;