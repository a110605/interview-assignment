import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
/**
 * Copyright IBM Corp. 2022, 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

/* eslint-disable react/jsx-key */

import React, { useRef, useMemo, useContext, useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import { Accordion, AccordionItem, Button, Search, Layer } from '@carbon/react';
import { rem } from '@carbon/layout';
import { pkg } from '../../../../../settings';
import { BATCH, CLEAR_FILTERS, INSTANT, PANEL } from './constants';
import cx from 'classnames';
import { motion } from 'framer-motion';
import { panelVariants, innerContainerVariants, actionSetVariants } from './motion/variants';
import { Close } from '@carbon/react/icons';
import { ActionSet } from '../../../../ActionSet';
import { FilterContext } from '.';
import { useFilters, useSubscribeToEventEmitter, useShouldDisableButtons } from './hooks';
var blockClass = "".concat(pkg.prefix, "--datagrid");
var componentClass = "".concat(blockClass, "-filter-panel");
var MotionActionSet = motion(ActionSet);
var FilterPanel = function FilterPanel(_ref) {
  var _cx;
  var _ref$title = _ref.title,
    title = _ref$title === void 0 ? 'Filter' : _ref$title,
    _ref$closeIconDescrip = _ref.closeIconDescription,
    closeIconDescription = _ref$closeIconDescrip === void 0 ? 'Close filter panel' : _ref$closeIconDescrip,
    _ref$updateMethod = _ref.updateMethod,
    updateMethod = _ref$updateMethod === void 0 ? BATCH : _ref$updateMethod,
    filterSections = _ref.filterSections,
    setAllFilters = _ref.setAllFilters,
    _ref$onApply = _ref.onApply,
    onApply = _ref$onApply === void 0 ? function () {} : _ref$onApply,
    _ref$onCancel = _ref.onCancel,
    onCancel = _ref$onCancel === void 0 ? function () {} : _ref$onCancel,
    _ref$onPanelOpen = _ref.onPanelOpen,
    onPanelOpen = _ref$onPanelOpen === void 0 ? function () {} : _ref$onPanelOpen,
    _ref$onPanelClose = _ref.onPanelClose,
    onPanelClose = _ref$onPanelClose === void 0 ? function () {} : _ref$onPanelClose,
    _ref$showFilterSearch = _ref.showFilterSearch,
    showFilterSearch = _ref$showFilterSearch === void 0 ? false : _ref$showFilterSearch,
    _ref$filterPanelMinHe = _ref.filterPanelMinHeight,
    filterPanelMinHeight = _ref$filterPanelMinHe === void 0 ? 600 : _ref$filterPanelMinHe,
    _ref$primaryActionLab = _ref.primaryActionLabel,
    primaryActionLabel = _ref$primaryActionLab === void 0 ? 'Apply' : _ref$primaryActionLab,
    _ref$secondaryActionL = _ref.secondaryActionLabel,
    secondaryActionLabel = _ref$secondaryActionL === void 0 ? 'Cancel' : _ref$secondaryActionL,
    _ref$searchLabelText = _ref.searchLabelText,
    searchLabelText = _ref$searchLabelText === void 0 ? 'Filter search' : _ref$searchLabelText,
    _ref$searchPlaceholde = _ref.searchPlaceholder,
    searchPlaceholder = _ref$searchPlaceholde === void 0 ? 'Find filters' : _ref$searchPlaceholde,
    _ref$reactTableFilter = _ref.reactTableFiltersState,
    reactTableFiltersState = _ref$reactTableFilter === void 0 ? [] : _ref$reactTableFilter;
  /** State */
  var _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    showDividerLine = _useState2[0],
    setShowDividerLine = _useState2[1];
  var _useFilters = useFilters({
      updateMethod: updateMethod,
      filters: filterSections,
      setAllFilters: setAllFilters,
      variation: PANEL,
      reactTableFiltersState: reactTableFiltersState,
      onCancel: onCancel
    }),
    filtersState = _useFilters.filtersState,
    prevFiltersObjectArrayRef = _useFilters.prevFiltersObjectArrayRef,
    prevFiltersRef = _useFilters.prevFiltersRef,
    cancel = _useFilters.cancel,
    reset = _useFilters.reset,
    renderFilter = _useFilters.renderFilter,
    filtersObjectArray = _useFilters.filtersObjectArray,
    lastAppliedFilters = _useFilters.lastAppliedFilters;

  /** Refs */
  var filterPanelRef = useRef();
  var filterHeadingRef = useRef();
  var filterSearchRef = useRef();
  var actionSetRef = useRef();

  /** State from hooks */
  var _useShouldDisableButt = useShouldDisableButtons({
      initialValue: true,
      filtersState: filtersState,
      prevFiltersRef: prevFiltersRef
    }),
    _useShouldDisableButt2 = _slicedToArray(_useShouldDisableButt, 2),
    shouldDisableButtons = _useShouldDisableButt2[0],
    setShouldDisableButtons = _useShouldDisableButt2[1];

  /** Memos */
  var showActionSet = useMemo(function () {
    return updateMethod === BATCH;
  }, [updateMethod]);

  /** Context */
  var _useContext = useContext(FilterContext),
    panelOpen = _useContext.panelOpen,
    setPanelOpen = _useContext.setPanelOpen;

  /** Methods */
  var closePanel = function closePanel() {
    cancel();
    setPanelOpen(false);
  };
  var apply = function apply() {
    setAllFilters(filtersObjectArray);
    // From the user
    onApply();
    // When the user clicks apply, the action set buttons should be disabled again
    setShouldDisableButtons(true);

    // updates the ref so next time the flyout opens we have records of the previous filters
    prevFiltersRef.current = JSON.stringify(filtersState);
    prevFiltersObjectArrayRef.current = JSON.stringify(filtersObjectArray);

    // Update the last applied filters
    lastAppliedFilters.current = JSON.stringify(filtersObjectArray);
  };
  var renderActionSet = function renderActionSet() {
    return showActionSet && /*#__PURE__*/React.createElement(MotionActionSet, {
      actions: [{
        key: 1,
        kind: 'primary',
        label: primaryActionLabel,
        onClick: apply,
        disabled: shouldDisableButtons
      }, {
        key: 2,
        kind: 'secondary',
        label: secondaryActionLabel,
        onClick: cancel,
        disabled: shouldDisableButtons
      }],
      className: "".concat(componentClass, "__action-set"),
      ref: actionSetRef,
      variants: actionSetVariants
    });
  };
  var onInnerContainerScroll = function onInnerContainerScroll(event) {
    if (event.target.scrollTop > 0) {
      setShowDividerLine(true);
    } else {
      setShowDividerLine(false);
    }
  };

  /** Effects */
  useEffect(function liftOpenStateToParent() {
    if (panelOpen) {
      onPanelOpen(panelOpen);
    } else {
      onPanelClose(panelOpen);
    }
  }, [panelOpen, onPanelClose, onPanelOpen]);
  useEffect(function setPanelMinimumHeight() {
    var _filterPanelRef$curre;
    (_filterPanelRef$curre = filterPanelRef.current) === null || _filterPanelRef$curre === void 0 ? void 0 : _filterPanelRef$curre.style.setProperty('--filter-panel-min-height', rem(filterPanelMinHeight));
  }, [filterPanelMinHeight]);
  useSubscribeToEventEmitter(CLEAR_FILTERS, reset);
  var getScrollableContainerHeight = function getScrollableContainerHeight() {
    var _filterHeadingRef$cur, _filterSearchRef$curr, _actionSetRef$current;
    var filterHeadingHeight = (_filterHeadingRef$cur = filterHeadingRef.current) === null || _filterHeadingRef$cur === void 0 ? void 0 : _filterHeadingRef$cur.getBoundingClientRect().height;
    var filterSearchHeight = (_filterSearchRef$curr = filterSearchRef.current) === null || _filterSearchRef$curr === void 0 ? void 0 : _filterSearchRef$curr.getBoundingClientRect().height;
    var actionSetHeight = (_actionSetRef$current = actionSetRef.current) === null || _actionSetRef$current === void 0 ? void 0 : _actionSetRef$current.getBoundingClientRect().height;
    var height = "calc(100vh - ".concat(filterHeadingHeight, "px - ").concat(showFilterSearch ? filterSearchHeight : 0, "px - ").concat(updateMethod === BATCH ? actionSetHeight : 0, "px)");
    return height;
  };
  return /*#__PURE__*/React.createElement(motion.div, {
    ref: filterPanelRef,
    className: cx(componentClass, "".concat(componentClass, "__container"), (_cx = {}, _defineProperty(_cx, "".concat(componentClass, "--open"), panelOpen), _defineProperty(_cx, "".concat(componentClass, "--batch"), showActionSet), _defineProperty(_cx, "".concat(componentClass, "--instant"), !showActionSet), _cx)),
    initial: false,
    animate: panelOpen ? 'visible' : 'hidden',
    variants: panelVariants
  }, /*#__PURE__*/React.createElement(motion.div, {
    variants: innerContainerVariants
  }, /*#__PURE__*/React.createElement("header", {
    ref: filterHeadingRef,
    className: cx("".concat(componentClass, "__heading"), _defineProperty({}, "".concat(componentClass, "__heading--with-divider"), showDividerLine))
  }, /*#__PURE__*/React.createElement("div", {
    className: "".concat(componentClass, "__title")
  }, title), /*#__PURE__*/React.createElement(Button, {
    hasIconOnly: true,
    renderIcon: function renderIcon(props) {
      return /*#__PURE__*/React.createElement(Close, _extends({
        size: 16
      }, props));
    },
    iconDescription: closeIconDescription,
    kind: "ghost",
    tooltipPosition: "bottom",
    tooltipAlignment: "end",
    onClick: closePanel
  }), showFilterSearch && /*#__PURE__*/React.createElement("div", {
    ref: filterSearchRef,
    className: "".concat(componentClass, "__search")
  }, /*#__PURE__*/React.createElement(Layer, null, /*#__PURE__*/React.createElement(Search, {
    labelText: searchLabelText,
    placeholder: searchPlaceholder,
    size: "sm"
  })))), /*#__PURE__*/React.createElement("div", {
    className: "".concat(componentClass, "__inner-container"),
    style: {
      height: getScrollableContainerHeight()
    },
    onScroll: onInnerContainerScroll
  }, filterSections.map(function (_ref2, index) {
    var _ref2$categoryTitle = _ref2.categoryTitle,
      categoryTitle = _ref2$categoryTitle === void 0 ? null : _ref2$categoryTitle,
      _ref2$filters = _ref2.filters,
      filters = _ref2$filters === void 0 ? [] : _ref2$filters,
      hasAccordion = _ref2.hasAccordion;
    return /*#__PURE__*/React.createElement("div", {
      key: index,
      className: "".concat(componentClass, "__category")
    }, categoryTitle && /*#__PURE__*/React.createElement("div", {
      className: "".concat(componentClass, "__category-title")
    }, categoryTitle), hasAccordion ? /*#__PURE__*/React.createElement(Accordion, null, filters.map(function (_ref3) {
      var filterLabel = _ref3.filterLabel,
        filter = _ref3.filter;
      return /*#__PURE__*/React.createElement(AccordionItem, {
        title: filterLabel,
        key: filterLabel
      }, renderFilter(filter));
    })) : filters.map(function (_ref4) {
      var filter = _ref4.filter;
      return renderFilter(filter);
    }));
  })), renderActionSet()));
};
FilterPanel.propTypes = {
  closeIconDescription: PropTypes.string,
  filterPanelMinHeight: PropTypes.number,
  filterSections: PropTypes.array,
  onApply: PropTypes.func,
  onCancel: PropTypes.func,
  onPanelClose: PropTypes.func,
  onPanelOpen: PropTypes.func,
  open: PropTypes.bool,
  primaryActionLabel: PropTypes.string,
  /**
   * Filters from react table's state
   */
  reactTableFiltersState: PropTypes.arrayOf(PropTypes.shape({
    id: PropTypes.string.isRequired,
    type: PropTypes.string.isRequired,
    value: PropTypes.any.isRequired
  })),
  searchLabelText: PropTypes.string,
  searchPlaceholder: PropTypes.string,
  secondaryActionLabel: PropTypes.string,
  setAllFilters: PropTypes.func.isRequired,
  showFilterSearch: PropTypes.bool,
  title: PropTypes.string,
  updateMethod: PropTypes.oneOf([BATCH, INSTANT])
};
export default FilterPanel;