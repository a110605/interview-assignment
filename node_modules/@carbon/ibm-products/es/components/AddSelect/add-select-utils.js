import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["children"];
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
//
// Copyright IBM Corp. 2022, 2022
//
// This source code is licensed under the Apache-2.0 license found in the
// LICENSE file in the root directory of this source tree.
//

/**
 * to be able to more easily and efficiently the child entries the data needs to be
 * normalized. this function recursively goes through the data array to build a single
 * object who's keys are the id's of every single entry
 * @param {object} data
 * @returns an object of normalized data
 */
export var normalize = function normalize(data) {
  var items = data.entries.reduce(function (prev, cur) {
    var children = cur.children,
      item = _objectWithoutProperties(cur, _excluded);
    prev[item.id] = item;
    if (children) {
      var childItems = normalize(children);
      return _objectSpread(_objectSpread({}, prev), childItems);
    }
    return prev;
  }, {});
  return items;
};

/**
 * takes in a global filters array and a flat list of items
 * it then searches through the items and finds any with the matching filter properties
 * and adds those values to the array
 * globalFilters looks like [{ id: someProperty }]
 * the returned array would look like [{ id: someProperty, opts: [value, value]}]
 * @param {Array} globalFilters - list of filter properties
 * @param {Array} items - items to search through
 * @returns an array of filter values
 */
export var getGlobalFilterValues = function getGlobalFilterValues(globalFilters, items) {
  var itemIds = Object.keys(items);
  var results = globalFilters.reduce(function (prevFilter, curFilter) {
    var filterId = curFilter.id;
    var filterOpts = itemIds.reduce(function (prevId, curId) {
      var curItem = items[curId];
      var value = curItem[filterId];
      if (value && !prevId.includes(value)) {
        prevId.push(value);
      }
      return prevId;
    }, []);
    prevFilter.push(_objectSpread({
      opts: filterOpts
    }, curFilter));
    return prevFilter;
  }, []);
  return results;
};
export var sortItems = function sortItems(attribute, direction) {
  return function (a, b) {
    var _a$attribute, _b$attribute;
    var valueA = (_a$attribute = a[attribute]) === null || _a$attribute === void 0 ? void 0 : _a$attribute.split(' ').join('');
    var valueB = (_b$attribute = b[attribute]) === null || _b$attribute === void 0 ? void 0 : _b$attribute.split(' ').join('');
    if (direction === 'desc') {
      return valueA > valueB ? -1 : 1;
    }
    return valueA < valueB ? -1 : 1;
  };
};
export var getFilteredItems = function getFilteredItems(useNormalizedItems, normalizedItems, searchTerm, globalFiltersApplied, globalFilterKeys, appliedGlobalFilters, sortFn, multi, items, path) {
  /**
   * useNormalizedItems just specifies if the data is hierarchical. the data structure
   * is an object and not an array.
   */
  if (useNormalizedItems) {
    var itemIds = Object.keys(normalizedItems);
    if (searchTerm || globalFiltersApplied) {
      var results = itemIds.reduce(function (prev, cur) {
        if (normalizedItems[cur].title.toLowerCase().includes(searchTerm.toLowerCase())) {
          prev.push(normalizedItems[cur]);
        }
        return prev;
      }, []).filter(function (item) {
        return globalFilterKeys.every(function (filter) {
          return item[filter] === appliedGlobalFilters[filter];
        });
      }).sort(sortFn);
      return results;
    }
    /**
     * multi select with hierarchy requires special consideration because columns
     * are built recursively, so the items are just returned
     */
    if (multi) {
      return items;
    }
    /**
     * because single add select with hierarchy isn't recursively built the data
     * structure has to be built around the path to maintain the folder structure
     */
    if (path.length > 1) {
      return path.reduce(function (prev, cur, curIdx) {
        var _prev$find, _prev$find$children;
        // because the root of the path never changes we can skip it
        if (curIdx === 0) {
          return prev;
        }
        var item = (_prev$find = prev.find(function (item) {
          return item.id === cur.id;
        })) === null || _prev$find === void 0 ? void 0 : (_prev$find$children = _prev$find.children) === null || _prev$find$children === void 0 ? void 0 : _prev$find$children.entries;
        return item;
      }, items.entries);
    }
    return items.entries;
  } else {
    if (searchTerm) {
      return items.entries.filter(function (item) {
        return item.title.toLowerCase().includes(searchTerm.toLowerCase());
      });
    }
    return items.entries;
  }
};